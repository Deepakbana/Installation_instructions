From 6c831d888d41214b7905f8f9538602fca190fd8f Mon Sep 17 00:00:00 2001
From: Vince Hendricks <vince.hendricks@freescale.com>
Date: Tue, 13 Oct 2009 11:31:50 -0400
Subject: [PATCH 1/2] Add the PMC daemon files.

Add the PMC daemon that will be used by the PMC client.

Signed-off-by: Vince Hendricks <vince.hendricks@freescale.com>
Signed-off-by: Paul Barrette <paul.barrette@freescale.com>
---
 controlInterface/pmci.c |    2 +-
 pmConfiguration/pmcd.c  | 7619 +++++++++++++++++++++++++++++++++++++++++++++++
 pmConfiguration/pmcd.h  |  189 ++
 3 files changed, 7809 insertions(+), 1 deletions(-)
 create mode 100644 pmConfiguration/pmcd.c
 create mode 100644 pmConfiguration/pmcd.h

diff --git a/controlInterface/pmci.c b/controlInterface/pmci.c
index fbac88e..ea5fc1f 100644
--- a/controlInterface/pmci.c
+++ b/controlInterface/pmci.c
@@ -1569,7 +1569,7 @@ static int _pmci_write(pmci_obj_t *pmci, pmp_header_t *header, int length, int r
         /* PMCI should be able to accurately predict the response length */
         LOG_STRING(LOG_WARNING, _PMCI_PREFIX,
                 "Mismatch response length: %"PRId32" != %"PRId32,
-                db_op.output.size, respLength);
+                (int)(db_op.output.size), respLength);
     }
 
     if ( db_op.output.size > 0 )
diff --git a/pmConfiguration/pmcd.c b/pmConfiguration/pmcd.c
new file mode 100644
index 0000000..78f3a76
--- /dev/null
+++ b/pmConfiguration/pmcd.c
@@ -0,0 +1,7619 @@
+/************************< BEGIN COPYRIGHT >************************
+ *  
+ *   Copyright 2009, Freescale Semiconductor, Inc.  All Rights Reserved.
+ *  
+ *    NOTICE: The information contained in this file is proprietary 
+ *    to Freescale Semiconductor and is being made available to 
+ *    Freescale's customers under a specific license agreement. 
+ *    Use or disclosure of this information is permissible only 
+ *    under the terms of the license agreement. 
+ *  
+ * 
+ ************************< END COPYRIGHT >***************************/
+/* ========================================================================== *
+ * Pattern Matcher Configuration Daemon
+ *
+ * File Name: pmcd.c
+ * Author   : Vince Hendricks
+ * ========================================================================== */
+
+/* linux/un.h clashes with sys/un.h which is used in pmla.h. So define 
+ * what we need here:
+ */
+#define UNIX_PATH_MAX 108 // From linux/un.h
+
+
+#include <sys/socket.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <libgen.h>
+extern int h_errno;
+
+#include <dll.h>
+#include <idx.h>
+#include <db.h>
+#include <pmll.h>
+#include <pmla.h>
+#include <cli.h>
+#include <pmapp.h>
+#include <pm_defs.h>
+#include <pm_defs_priv.h>
+
+
+#include "pmcapi.h"
+#include "pmc_private.h"
+#include "pmcd.h"
+
+#define REGISTER_CMD(idx, f_p) {cmd_p = (_pmcd_command_t *)calloc(sizeof(_pmcd_command_t), 1); \
+   if (cmd_p == NULL)                                                             \
+   {                                                                              \
+      LOG_PRINT("Failed to allocate memory for command: %s\n", strerror(errno));  \
+      return errno;                                                               \
+   }                                                                              \
+   cmd_p->ftn_p = f_p;                                                            \
+   command_table_p[idx] = cmd_p;                                                  \
+}
+
+#define EOFERROR_S "EOF encountered while reading a regex record.\n"
+#define FAILERROR_S "Failed to read a regex record.  \"%s\"\n"
+
+#define _PMCD_SUCCESS_STR "Success"
+
+/* -------------------------------------------------------------------------- *
+ * Concat snprintf macro.  Like snprintf, but concats to the input string.
+ *
+ * Parameters:
+ *
+ *   orig_str_pp  - a pointer to a pointer to the original string
+ *   max_size     - the maximum size of the final string (the 'n' in snprintf)
+ *   format_p     - the format string for snprintf
+ *   ...          - the variable parameters for snprintf
+ * -------------------------------------------------------------------------- */
+#define _PMCD_CSNPRINTF(orig_str_pp, max_size, format_p, ...)        \
+   if (*orig_str_pp == NULL)                                         \
+   {                                                                 \
+      *orig_str_pp = (char *)calloc(max_size + 2, 1);                \
+   }                                                                 \
+   else                                                              \
+   {                                                                 \
+      if (max_size <= strlen(*orig_str_pp))                          \
+      {                                                              \
+         /* Do nothing */                                            \
+      }                                                              \
+      else                                                           \
+      {                                                              \
+         *orig_str_pp = (char *)realloc(*orig_str_pp, max_size + 2); \
+                                                                     \
+         memset(*orig_str_pp + strlen(*orig_str_pp) + 1,             \
+                0,                                                   \
+                (max_size  + 1 - strlen(*orig_str_pp)));             \
+                                                                     \
+         memset(*orig_str_pp + strlen(*orig_str_pp),                 \
+                '\n',                                                \
+                1);                                                  \
+                                                                     \
+         snprintf(*orig_str_pp + strlen(*orig_str_pp),               \
+                  max_size - strlen(*orig_str_pp),                   \
+                  format_p,                                          \
+                  ##__VA_ARGS__);                                    \
+      }                                                              \
+   }
+
+/* This variable will store the default PMCD DB handle. */
+static handle_t  _pmcd_db_handle_sg = HANDLE_NULL;
+
+/*
+ * Get an analysis of the patterns in the database.
+ *
+ * !! This function will allocate the memory for the string, so
+ *    the user must free the string when finished.
+ */
+pmll_status_t pmll_analysis(unsigned int   pmllDbHandle,
+                            char         **str_p);
+
+/* -------------------------------------------------------------------------- *
+ * Cleanup function
+ * -------------------------------------------------------------------------- */
+static void _pmcd_cleanup (void)
+{
+   LOG_PRINT("Cleanup and exit\n");
+   fclose(_pmc_log_stream_pg);
+   unlink(SERVER_SOCK_FILE_PATH);
+   exit(0);
+}
+
+/* -------------------------------------------------------------------------- *
+ * Signal handlers
+ * -------------------------------------------------------------------------- */
+static void _pmcd_int_sig_handler(int        sig,
+                                  siginfo_t *sig_info_p,
+                                  void      *ctx_p)
+{
+   // Get rid of warnings
+   sig = sig;
+   sig_info_p = sig_info_p;
+   ctx_p = ctx_p;
+   // Get rid of warnings
+
+   _pmcd_cleanup();
+}
+
+static void _pmcd_pipe_sig_handler(int        sig,
+                                   siginfo_t *sig_info_p,
+                                   void      *ctx_p)
+{
+   // Get rid of warnings
+   sig = sig;
+   sig_info_p = sig_info_p;
+   ctx_p = ctx_p;
+   // Get rid of warnings
+
+   // Do nothing, ignore.  We will cleanup this connection in the 
+   // code elsewhere.
+}
+
+/* -------------------------------------------------------------------------- *
+ * Set a socket to non blocking
+ * -------------------------------------------------------------------------- */
+static int _pmcd_set_nonblock(int sock_fd)
+{
+   int flags;
+
+   flags = fcntl(sock_fd,F_GETFL,0);
+
+   if (flags == -1)
+   {
+      LOG_PRINT("Failed to get current socket flags: %s\n",
+                strerror(errno));
+      return errno;
+   }
+
+   fcntl(sock_fd, F_SETFL, flags | O_NONBLOCK);
+
+   if (flags == -1)
+   {
+      LOG_PRINT("Failed to set socket non blocking: %s\n",
+                strerror(errno));
+      return errno;
+   }
+
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Accept client
+ * -------------------------------------------------------------------------- */
+static int _pmcd_accept_client(int         server_sock_fd,
+                               dll_list_t *client_list_p)
+{
+   socklen_t            len;
+   struct sockaddr_un   client_address;
+   int                  client_sock_fd;
+   _pmcd_client_data_t *client_data_p;
+
+   /* Accept a connection */
+   len = sizeof(client_address);
+
+   client_sock_fd = accept(server_sock_fd,
+                           (struct sockaddr *)&client_address,
+                           &len);
+
+   if (client_sock_fd > -1)
+   {
+      client_data_p = (_pmcd_client_data_t *)calloc(sizeof(_pmcd_client_data_t), 1);
+
+      if (client_data_p == NULL)
+      {
+         LOG_PRINT("Failed to allocate memory for client data: %s\n",
+                 strerror(errno));
+         return errno;
+      }
+
+      if (_pmcd_set_nonblock(client_sock_fd) != 0)
+      {
+         return errno;
+      }
+
+      client_data_p->sock_fd = client_sock_fd;
+
+      dll_add_to_back(client_list_p,
+                      &(client_data_p->dll_node));
+
+      //LOG_PRINT("Client connected\n");
+   }
+
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Read client data
+ * -------------------------------------------------------------------------- */
+static int _pmcd_read_clients(dll_list_t *client_list_p)
+{
+   dll_node_t          *node_p;
+   char                 buffer_p[_PMCD_BUFFER_SIZE];
+   uint8_t             *tmp_buffer_p;
+   int                  tmp_size;
+   _pmcd_client_data_t *item_p;
+   int                  num_bytes;
+
+   /* Go through active client sockets */
+   node_p = dll_get_first(client_list_p);
+
+   while (node_p != NULL)
+   {
+      item_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                        _pmcd_client_data_t,
+                                        dll_node);
+
+      if (item_p->sock_fd > -1)
+      {
+         memset(buffer_p, 0, _PMCD_BUFFER_SIZE);
+   
+         num_bytes = recv(item_p->sock_fd,
+                          buffer_p,
+                          _PMCD_BUFFER_SIZE,
+                          0);
+   
+         /* If the peer has closed the connection or there is an error on the
+          * client socket then close it. */
+         if (num_bytes == 0)
+         {
+            /* Peer closed connection */
+            close(item_p->sock_fd);
+            item_p->sock_fd = -1;
+         }
+         else if (num_bytes == -1)
+         {
+            /* This is a nonblocking socket, so EAGAIN or EWOULDBLOCK are fine,
+             * there is just no data, but anything else is an error. */
+            if (errno != EAGAIN && errno != EWOULDBLOCK)
+            {
+               /* Some other error happened, so close it */
+               close(item_p->sock_fd);
+               item_p->sock_fd = -1;
+            }
+         }
+         else
+         {
+            /* Store the retrieved bytes for this client */
+            if (item_p->read_buffer_p == NULL)
+            {
+               item_p->read_buffer_p = (uint8_t *)calloc(num_bytes, 1);
+
+               if (item_p->read_buffer_p == NULL)
+               {
+                  LOG_PRINT("Failed to allocate memory for client read buffer: %s\n",
+                            strerror(errno));
+                  return errno;
+               }
+
+               memcpy(item_p->read_buffer_p, buffer_p, num_bytes);
+               item_p->read_buffer_size = num_bytes;
+            }
+            else
+            {
+               tmp_buffer_p = item_p->read_buffer_p;
+               tmp_size     = item_p->read_buffer_size;
+
+               item_p->read_buffer_p = (uint8_t *)calloc(tmp_size + num_bytes, 1);
+
+               if (item_p->read_buffer_p == NULL)
+               {
+                  LOG_PRINT("Failed to allocate memory for client read buffer: %s\n",
+                            strerror(errno));
+                  return errno;
+               }
+
+               memcpy(item_p->read_buffer_p, tmp_buffer_p, tmp_size);
+               free(tmp_buffer_p);
+
+               tmp_buffer_p = item_p->read_buffer_p + tmp_size;
+
+               memcpy(tmp_buffer_p, buffer_p, num_bytes);
+
+               item_p->read_buffer_size = tmp_size + num_bytes;
+            }
+         }
+      }
+
+      node_p = dll_get_next_node(client_list_p, node_p);
+   }
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Wait for new connection for data from an existing client
+ * -------------------------------------------------------------------------- */
+static int _pmcd_wait_for_input(int         server_sock_fd,
+                                dll_list_t *client_list_p)
+{
+   dll_node_t          *node_p;
+   _pmcd_client_data_t *item_p;
+   fd_set               set;
+   int                  num_ready;
+
+   FD_ZERO(&set);
+
+   /* Add server listen socket to list of fds to select on */
+   FD_SET(server_sock_fd, &set);
+
+   /* Go through active client sockets and add each client fd to set*/
+   node_p = dll_get_first(client_list_p);
+
+   while (node_p != NULL)
+   {
+      item_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                        _pmcd_client_data_t,
+                                        dll_node);
+
+      if (item_p->sock_fd > -1)
+      {
+         FD_SET(item_p->sock_fd, &set);
+      }
+
+      node_p = dll_get_next_node(client_list_p, node_p);
+   }
+
+   /* Block until we have something to deal with */
+   num_ready = select(FD_SETSIZE,
+                      &set,  /* read set */
+                      NULL,  /* write set */
+                      NULL,  /* error set */
+                      NULL); /* No timeout, block until something is available */
+           
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Process client requests
+ * -------------------------------------------------------------------------- */
+static int _pmcd_process_requests(dll_list_t       *client_list_p,
+                                  _pmcd_command_t **command_table_p)
+{
+   dll_node_t          *node_p;
+   dll_node_t          *del_node_p;
+   _pmcd_client_data_t *item_p;
+   _pmcd_command_t     *cmd_p;
+   uint8_t             *resp_p;
+   int                  ret_val;
+   uint32_t             msg_type;
+   uint32_t             msg_len;
+   uint8_t             *cur_buf_pos_p;
+   uint8_t             *remaining_buffer_p;
+   uint32_t             remaining_buffer_size;
+   uint32_t             msg_type_size;
+   uint32_t             msg_len_size;
+
+   msg_type_size = sizeof(uint32_t);
+   msg_len_size  = sizeof(uint32_t);
+
+   /* Go through active client sockets */
+   node_p = dll_get_first(client_list_p);
+
+   while (node_p != NULL)
+   {
+      item_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                        _pmcd_client_data_t,
+                                        dll_node);
+
+      /* Check for incoming request */
+      if (item_p->read_buffer_p != NULL)
+      {
+         /* Check for a complete request */
+         if (item_p->read_buffer_size >= msg_type_size + msg_len_size)
+         {
+            cur_buf_pos_p = item_p->read_buffer_p;
+
+            msg_type       = *((uint32_t *)(cur_buf_pos_p));
+            cur_buf_pos_p += sizeof(uint32_t);
+
+            msg_len        = *((uint32_t *)cur_buf_pos_p);
+            cur_buf_pos_p += sizeof(uint32_t);
+
+            if (msg_len >= item_p->read_buffer_size -
+                           msg_type_size            -
+                           msg_len_size)
+            {
+               /* We have a complete request, so remove the current
+                * msg from the buffer and update the buffer to only
+                * contain any remaining msgs */
+               remaining_buffer_size = item_p->read_buffer_size -
+                                       msg_type_size            -
+                                       msg_len_size             -
+                                       msg_len;
+
+               /* Process request */
+               cmd_p = command_table_p[msg_type];
+
+               if (cmd_p == NULL)
+               {
+                  LOG_PRINT("No command for command code %d:\n",
+                            msg_type);
+   
+                  return EINVAL;
+               }
+
+               // Call the appropriate function
+               ret_val = (*cmd_p->ftn_p) (cur_buf_pos_p,
+                                          &resp_p);
+
+               if (ret_val != 0)
+               {
+                  LOG_PRINT("Error while calling cmd with msg_type %d : %s\n",
+                            msg_type,
+                            strerror(errno));
+   
+                  return ret_val;
+               }
+
+               item_p->write_buffer_p    = resp_p;
+               item_p->write_buffer_size = MSG_SIZE(resp_p);
+
+               /* Deal with any remaining requests */
+               if (remaining_buffer_size > 0)
+               {
+                  remaining_buffer_p = (uint8_t *)calloc(remaining_buffer_size, 1);
+   
+                  memcpy(remaining_buffer_p,
+                         item_p->read_buffer_p + msg_type_size + msg_len_size + msg_len,
+                         remaining_buffer_size);
+
+                  free(item_p->read_buffer_p);
+
+                  item_p->read_buffer_p = remaining_buffer_p;
+                  item_p->read_buffer_size = remaining_buffer_size;
+               }
+               else
+               {
+                  free(item_p->read_buffer_p);
+                  item_p->read_buffer_p    = NULL;
+                  item_p->read_buffer_size = 0;
+               }
+            }
+         }
+      }
+
+      /* Check for outgoing response */
+      if (item_p->sock_fd        != -1 &&
+          item_p->write_buffer_p != NULL)
+      {
+         int chunk_size = 500;
+
+         void *cur_pos_p  = item_p->write_buffer_p;
+         int   bytes_left = item_p->write_buffer_size;
+
+         while (bytes_left > 0)
+         {
+            if (bytes_left >= chunk_size)
+            {
+               if(send(item_p->sock_fd,
+                       cur_pos_p,
+                       chunk_size,
+                       0) == -1)
+               {
+                  LOG_PRINT("Failed to write to client: %s\n",
+                            strerror(errno));
+
+                  item_p->sock_fd = -1;
+                  break;
+               }
+               cur_pos_p  += chunk_size;
+               bytes_left -= chunk_size;
+            }
+            else
+            {
+               if(send(item_p->sock_fd,
+                       cur_pos_p,
+                       bytes_left,
+                       0) == -1)
+               {
+                  LOG_PRINT("Failed to write to client: %s\n",
+                            strerror(errno));
+
+                  item_p->sock_fd = -1;
+                  break;
+               }
+               bytes_left = 0;
+            }
+         }
+
+         MSG_FREE(item_p->write_buffer_p);
+         item_p->write_buffer_size = 0;
+      }
+
+      /* Cleanup connection if the client is done.
+       * Any outstanding requests were dealt with above */
+      if (item_p->sock_fd == -1)
+      {
+         del_node_p = node_p;
+         node_p = dll_get_next_node(client_list_p, node_p);
+  
+         dll_remove_node(del_node_p);
+         free(item_p);
+
+         continue;
+      }
+
+      node_p = dll_get_next_node(client_list_p, node_p);
+   }
+   return 0;
+}
+
+/* Receive the next message from the specified PMLA connection.
+ *
+ * param pmlaHandle   ID of the PMLA connection to use.
+ * param msg_p        Buffer where the received message is stored. 
+ * param msgSize_p    Size of the received message.
+ * retval             true upon success; false otherwise.  When true
+ *                    is returned, the received message is stored in
+ *                    msg_p and the size of the received message is
+ *                    stored in msgSize_p.  Note that it is the
+ *                    responsibility of the caller to free the msg_p
+ *                    buffer with a call to the mem_free function.
+ */
+static bool _pmcd_msg_receive(handle_t    pmlaHandle,
+                              pmp_msg_t **msg_p,
+                              uint32_t   *msgSize_p)
+{
+   PmlaError_t  pmlaStatus = pmlaSuccess_c;
+   uint32_t     msgSize    = 0;
+   pmp_msg_t    msg;
+ 
+   /* Reset the message buffer. */
+   *msg_p = NULL;
+ 
+   /* Attempt to read the message. */
+   pmlaStatus = pmlaRecv(pmlaHandle, &msg);
+ 
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      LOG_PRINT("Failed to read the message from PMLA. %s\n", 
+                pmlaErrorString(pmlaStatus));
+     return false;
+   }
+   
+   /* Allocate a buffer for the message. */
+   msgSize = PMP_PMHWTOHL(msg.header.msgLength);
+
+   *msgSize_p = msgSize;
+   
+   *msg_p = (pmp_msg_t *)calloc(1, msgSize);
+
+   if (*msg_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate a %u byte long buffer needed to "
+                "read a PMLA message of that size.\n",
+                 msgSize);
+     return false;
+   }
+ 
+   /* Copy the read message header into the message buffer. */
+   memcpy(*msg_p, &msg, msgSize);
+   
+   return true;
+} /* _pmcd_msg_receive */
+
+
+/* Send a message over the specified PMLA connection.
+ *
+ * param pmlaHandle   ID of the PMLA connection to use.
+ * param msg_p        Pointer to the message to be sent.
+ * retval             true upon success; false otherwise.  Note that
+ *                    this function does not free the passed in
+ *                    message buffer. 
+ */
+static bool _pmcd_msg_send(handle_t   pmlaHandle,
+                           pmp_msg_t *msg_p)
+{
+   bool         status     = true;
+   PmlaError_t  pmlaStatus = pmlaSuccess_c;
+   
+   /* Send the message. */
+   pmlaStatus = pmlaSend(pmlaHandle, msg_p);
+ 
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      LOG_PRINT("Failed to send a PMLA message. %s\n", 
+                pmlaErrorString(pmlaStatus));
+     status = false;
+   }
+     
+   return status;
+} /* _pmcd_msg_send */
+
+
+/* Retrieves the next message ID to use.
+ *
+ * This is a very simple function.  The function does not ensure that
+ * the message ID it returns is not already in use.
+ *
+ * retval  The next message ID to use.
+ */
+static uint64_t _pmcd_msg_id_get(void)
+{
+  static uint64_t  msgId = 0;
+  
+  return msgId++;
+} /* _pmcd_msg_id_get */
+
+
+/* Write an attribute to the PM H/W.
+ *
+ * param pmlaHandle   ID of the communication channel to use.
+ * param attributeId  ID of the attribute to be written.
+ * param buffer_p     Pointer to the buffer with the attribute value.
+ * param size         Size of the attribute value.
+ * retval             true upon success; false otherwise. 
+ */
+static bool _pmcd_attribute_write(handle_t                  pmlaHandle,
+                                  pmp_attribute_id_field_t  attributeId,
+                                  void                     *buffer_p,
+                                  uint32_t                  size)
+{
+   bool                             boolStatus  = true;
+   uint32_t                         msgLength   = 0;
+   pmp_msg_t                       *msgBuffer_p = NULL;
+   pmp_attribute_set_request_msg_t *msg_p       = NULL;
+   
+   /* Allocate memory needed to build the message. */
+   msgLength = PMP_ATTRIBUTE_SET_REQUEST_MSG_SIZE(size);
+ 
+   msgBuffer_p = (pmp_msg_t *)calloc(1, msgLength);
+ 
+   if (msgBuffer_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate %u bytes of memory needed to send "
+                "an attribute write request.\n", msgLength);
+      return false;
+   }
+
+   msg_p = &msgBuffer_p->requestMsg.attributeSetRequestMsg;
+ 
+ 
+   /* Build the message. */
+   msg_p->header.protocolVersion = PMP_CURRENT_VERSION;
+   msg_p->header.msgType         = pmp_attribute_set_request_msg_type_e;
+   msg_p->header.msgId           = PMP_HTOPMHWLL(_pmcd_msg_id_get());
+   msg_p->header.msgLength       = PMP_HTOPMHWL(msgLength);
+   msg_p->attributeId            = PMP_HTOPMHWL(attributeId);
+
+   memcpy(&msg_p->attributeValue, buffer_p, size);
+ 
+   /* Send the message. */
+   boolStatus = _pmcd_msg_send(pmlaHandle, msgBuffer_p);
+    
+   /* Free the message buffer. */
+   if (msgBuffer_p != NULL)
+   {
+      free(msgBuffer_p);
+   }
+   
+   return boolStatus;
+} /* _pmcd_attribute_write */
+
+/* Read an attribute from the PM H/W.
+ *
+ * param pmlaHandle   ID of the communication channel to use.
+ * param attributeId  ID of the attribute to be written.
+ * param buffer_p     Pointer to the buffer where to store the attribute.
+ * param size_p       Pointer to store the length of the read attribute.
+ * retval             true upon success; false otherwise. 
+ */
+static bool _pmcd_attribute_read(handle_t                  pmlaHandle,
+                                 pmp_attribute_id_field_t  attributeId,
+                                 void                     *buffer_p,
+                                 uint32_t                 *size_p)
+{
+   bool                             status        = true;
+   uint32_t                         msgSize       = 0;
+   pmp_message_type_t               msgType       = pmp_attribute_get_request_msg_type_e;
+   uint32_t                         msgBufferSize = sizeof(pmp_msg_t);
+   pmp_msg_t                       *msgBuffer_p   = (pmp_msg_t *)calloc(1, msgBufferSize);
+   uint32_t                         msgId         = _pmcd_msg_id_get();
+   pmp_msg_t                       *replyMsg_p    = NULL;
+   uint32_t                         replyMsgSize  = 0;
+   pmp_message_type_t               replyMsgType  = pmp_attribute_get_reply_msg_type_e;
+   uint32_t                         attributeSize = 0;
+   pmp_attribute_get_request_msg_t *requestMsg_p  = NULL;
+ 
+   /* Check the initializations above. */
+   if (msgBuffer_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate a %u byte long message buffer.\n", 
+                msgBufferSize);
+      return false;
+   }
+ 
+   /* Build and send the read request message. */
+   requestMsg_p = (&msgBuffer_p->requestMsg.attributeGetRequestMsg);
+ 
+   msgSize = PMP_ATTRIBUTE_GET_REQUEST_MSG_SIZE;
+
+   memset(requestMsg_p, 0, msgSize);
+
+   requestMsg_p->header.protocolVersion = PMP_CURRENT_VERSION;
+   requestMsg_p->header.msgType         = msgType;
+   requestMsg_p->header.reserved        = 0;
+   requestMsg_p->header.msgLength       = PMP_PMHWTOHL(msgSize);
+   requestMsg_p->header.msgId           = PMP_HTOPMHWLL(msgId);
+   requestMsg_p->attributeId            = PMP_HTOPMHWL(attributeId);
+
+   status = _pmcd_msg_send(pmlaHandle, msgBuffer_p);
+ 
+   if (status == true)
+   {
+      /* Read the reply message. */
+      status = _pmcd_msg_receive(pmlaHandle, &replyMsg_p, &replyMsgSize);
+
+      if (status == true)
+      {
+         if (replyMsgType == replyMsg_p->header.msgType)
+         {
+            /* Copy the attribute into the provided buffer. */
+            attributeSize = replyMsgSize - 
+                            PMP_ATTRIBUTE_GET_REPLY_EMPTY_MSG_SIZE;
+
+            memcpy(buffer_p, 
+                   &replyMsg_p->replyMsg.attributeGetReplyMsg.attributeValue,
+                   attributeSize);
+         }
+         else
+         {
+            LOG_PRINT("Received message type %u but was expecting %u.\n",
+                      replyMsg_p->header.msgType,
+                      replyMsgType);
+            status = false;
+         }
+      }
+  
+      /* Free the reply message buffer. */
+      if (replyMsg_p != NULL)
+      {
+         free(replyMsg_p);
+      }
+   } /* if - no errors so far - read the reply message. */
+   
+   /* Free the request message buffer. */
+   if (msgBuffer_p != NULL)
+   {
+      free(msgBuffer_p);
+   }
+   
+   *size_p = attributeSize;
+
+   return status;
+} /* _pmcd_attribute_read */
+
+/* -------------------------------------------------------------------------- *
+ * Analyze command.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_analysis(uint8_t  *params_p,
+                          uint8_t **resp_p)
+{
+   _pmcd_db_t    *pmcdDb_p     = _pmcd_db_handle_sg;
+   unsigned int   pmllDbHandle = pmcdDb_p->llDbHandle;
+   char          *log_str_p    = NULL;
+   char          *info_msg_p   = NULL;
+   pmll_status_t  pmll_status  = pmll_ok_e;
+   pmc_status_t   status       = pmc_ok_e;
+   
+   /* params_p unused */
+   params_p = params_p;
+
+   MSG_INIT(*resp_p, _pmc_analysis_response_e);
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   pmll_status = pmll_analysis(pmllDbHandle, &log_str_p);
+
+   if (pmll_status != pmll_ok_e)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "The analysis failed with the following error: \"%s\".\n",
+               pmll_error_string_get(pmll_status));
+
+      status = pmc_analysis_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "The analysis was successful.\n");
+
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD(*resp_p, log_str_p);
+   }
+
+   free(info_msg_p);
+
+   return 0;
+} /* _pmcd_analysis */
+
+/* -------------------------------------------------------------------------- *
+ * Stats command.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_stats(uint8_t  *params_p,
+                       uint8_t **resp_p)
+{
+   _pmcd_db_t            *pmcdDb_p      = _pmcd_db_handle_sg;
+   unsigned int           pmllDbHandle  = pmcdDb_p->llDbHandle;
+   char                  *info_msg_p    = NULL;
+   pmll_status_t          pmll_status   = pmll_ok_e;
+   pmc_status_t           status        = pmc_ok_e;
+   pmll_stats_t           ll_stats;
+   pmp_statistics_attr_t  hw_stats;
+   bool                   rc            = false;
+   uint32_t               attributeSize = 0;
+   
+   /* params_p unused */
+   params_p = params_p;
+
+   MSG_INIT(*resp_p, _pmc_stats_response_e);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   rc = _pmcd_attribute_read(pmcdDb_p->pmlaForPmcdHandle, 
+                             pmp_statistics_attr_id_e,
+                             &hw_stats,
+                             &attributeSize);
+
+   pmll_status = pmll_stats_get(pmllDbHandle, &ll_stats);
+
+   if (rc == false || (pmll_status != pmll_ok_e))
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Unable to retrieve the stats. \n");
+
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "The stats get was successful.\n");
+
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmInputBytes);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmOutputBytes);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmTriggerOneByteHits);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmTriggerTwoByteHits);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmTriggerVariableHits);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmTriggerSpecialHits);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmConfidenceHits);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmMatches);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmDxeExecutions);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmEndOfSuiExecutions);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmSuiMatchingPatterns);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmSuiGeneratingReports);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmInputSuis);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.pmSelectedMatches);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.dfInputBytes);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.dfOutputBytes);
+      MSG_ADD_UINT64_FIELD(*resp_p, hw_stats.dfDecompressions);
+
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.dxeSreEntryNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.dxeSreBaseEntryNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.dxeSreExtensionEntryNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.dxeSreAllocatedExtensionEntryNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.dxeSreAvailableExtensionEntryNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreSessionCtxNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreSessionCtxSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreSessionDigestSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreSessionFlagsSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreSessionCtxAreaSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreAllocatedSessionCtxAreaSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.sreAvailableSessionCtxAreaSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.patternMaxNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.expNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.specialPatternNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.oneBytePatternNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.twoBytePatternNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.variablePatternNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.totalPatternNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.variableTriggerSize);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.statefulRuleMaxNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.statelessRuleMaxNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.totalRuleMaxNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.statelessRuleNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.statefulRuleNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.totalRuleNum);
+      MSG_ADD_UINT32_FIELD(*resp_p, ll_stats.endOfSuiReactionNum);
+   }
+
+   free(info_msg_p);
+
+   return 0;
+} /* _pmcd_stats */
+
+/* -------------------------------------------------------------------------- *
+ * Stats reset command.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_stats_reset(uint8_t  *params_p,
+                             uint8_t **resp_p)
+{
+   _pmcd_db_t            *pmcdDb_p      = _pmcd_db_handle_sg;
+   char                  *info_msg_p    = NULL;
+   bool                   rc            = false;
+   
+   /* params_p unused */
+   params_p = params_p;
+
+   MSG_INIT(*resp_p, _pmc_stats_reset_response_e);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   /* Reset the snapshot stats. */
+   memset(&pmcdDb_p->snapshot, 0, sizeof(pmp_statistics_attr_t));
+
+   /* Reset the aggregate PM H/W stats. counters. */
+   rc = _pmcd_attribute_write(pmcdDb_p->pmlaForPmcdHandle,
+                              pmp_statistics_attr_id_e,
+                              NULL,
+                              0);
+
+   free(info_msg_p);
+
+   return 0;
+} /* _pmcd_stats_reset */
+
+/* 
+ *  Allocates a new exp. record and adds it to the PMCD exp. DB.
+ *
+ * param expDbHandle   DB handle to add the expression record to.
+ * param pmExp_p       Data to initialize the new record with.
+ * param exp_p         Expression string.
+ * param options_p     Expression options string.
+ * param llIndex       Linker-loader index to be stored in the new
+ *                     expression record.
+ * retval              Pointer to the newly created and added
+ *                     expression record on successs; NULL pointer
+ *                     otherwise.
+ */
+static _pmcd_exp_record_t *_pmcd_exp_add(char                    **info_msg_p,
+                                         const handle_t            expDbHandle,
+                                         pm_exp_record_v_1_0_1_t  *pmExp_p,
+                                         const char               *exp_p,           
+                                         const char               *options_p,
+                                         uint8_t                   set,
+                                         uint16_t                  subset,
+                                         const uint32_t            llIndex)
+{
+   _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+
+   /* Allocate and clear a new expression record. */
+   _pmcd_exp_record_t *pmcdExp_p = calloc(1, sizeof(_pmcd_exp_record_t));
+
+   if (pmcdExp_p == NULL)
+   {
+      _PMCD_CSNPRINTF(info_msg_p,
+                      strlen(*info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                      "Failed to allocate a new expression record.\n");
+      return NULL;
+   }
+
+   /* Initialize the newly allocated PMCD expression record. */
+   strncpy(pmcdExp_p->name_s,    pmExp_p->name_s, _PMCD_NAME_STRING_MAX_SIZE);
+   strncpy(pmcdExp_p->exp_s,     exp_p,           _PMCD_EXP_STRING_MAX_SIZE);
+   strncpy(pmcdExp_p->options_s, options_p,       _PMCD_EXP_OPTIONS_STRING_MAX_SIZE);
+
+   pmcdExp_p->set    = set;
+   pmcdExp_p->subset = subset;
+
+   pmcdExp_p->name_s[_PMCD_NAME_STRING_MAX_SIZE - 1]           = 0;
+   pmcdExp_p->exp_s[_PMCD_EXP_STRING_MAX_SIZE - 1]             = 0;
+   pmcdExp_p->options_s[_PMCD_EXP_OPTIONS_STRING_MAX_SIZE - 1] = 0;
+   pmcdExp_p->llIndex                                          = llIndex;
+ 
+   /* Add the new expression record to the PMCD expression DB. */
+   uint32_t    pmcdIndex = IDX_NULL_INDEX;
+   db_status_t dbStatus  = db_record_add(expDbHandle,
+                                         pmExp_p->name_s, 
+                                         pmcdExp_p,
+                                         &pmcdIndex);
+
+   if (dbStatus != db_ok_e)
+   {
+      _PMCD_CSNPRINTF(info_msg_p,
+                      strlen(*info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                      "Failed to add a new expression record to "
+                      "the PMCD expression DB.  \"%s\"\n",
+                      db_error_string_get(dbStatus));
+
+      free(pmcdExp_p);
+      return NULL;
+   }
+ 
+   /* Store the PMCD index in the expression record. */
+   pmcdExp_p->pmcdIndex = pmcdIndex;
+ 
+   /* Add the expression record to the appropriate set list */
+   dll_add_to_back(&((pmcdDb_p->set)[set]),
+                   &(pmcdExp_p->dll_node));
+
+   return pmcdExp_p;
+} /* _pmcd_exp_add */
+
+/* -------------------------------------------------------------------------- *
+ * Commit database
+ * -------------------------------------------------------------------------- */
+static int _pmcd_commit(uint8_t  *params_p,
+                        uint8_t **resp_p)
+{
+   pmll_status_t  pmllStatus = pmll_ok_e;
+   _pmcd_db_t    *pmcdDb_p   = _pmcd_db_handle_sg;
+   pmc_status_t   status     = pmc_ok_e;
+   char          *info_msg_p = NULL;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   /* There are no params to "commit" command. Get rid of warning. */
+   params_p = params_p;
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_commit_response_e);
+
+   /* Do the commit */
+   pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+   if (pmllStatus != pmll_ok_e)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "The commit failed with the following error: \"%s\".\n",
+               pmll_error_string_get(pmllStatus));
+
+      status = pmc_commit_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "The commit was successful.\n");
+
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Add binary expression file.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_add_bin_expr_file(uint8_t  *params_p,
+                                   uint8_t **resp_p)
+{
+   char                    *filename_p;
+   bool                     auto_commit;
+   FILE                    *binFile_p;
+   pm_exp_record_v_1_0_1_t  exp;
+   pm_pattern_record_t     *currentPattern_p      = NULL;
+   pm_pattern_record_t     *previousPattern_p     = NULL;
+   uint32_t                 recordType            = 0;
+   uint32_t                 recordVersion         = 0;
+   uint32_t                 pmeVersion            = 0;
+   uint32_t                 siliconVersion        = 0;
+   uint32_t                 expNameLength         = 0;
+   uint32_t                 expStringLength       = 0;
+   uint32_t                 optionStringLength    = 0;
+   uint32_t                 patternsNum           = 0;
+   uint32_t                 count                 = 0;
+   uint32_t                 keyElementEntrySize   = 0;
+   uint32_t                 confirmationEntrySize = 0;
+   size_t                   readNum               = 0;
+   uint32_t                 llIndex               = 0;
+   pmll_status_t            pmllStatus            = pmll_ok_e;
+   uint32_t                 failedExpCount        = 0;
+   uint32_t                 addedExpCount         = 0;
+   char                    *expString_p           = NULL;
+   char                    *optionString_p        = NULL;
+   char                    *expNameString_p       = NULL;
+   uint32_t                 cleanup               = 0;
+   _pmcd_db_t              *pmcdDb_p              = _pmcd_db_handle_sg;
+   unsigned int             llDbHandle            = pmcdDb_p->llDbHandle;
+   pmc_status_t             status                = pmc_ok_e;
+   char                    *info_msg_p            = NULL;
+
+   /* 2 parameters:
+    *    - string -> file name
+    *    - bool   -> auto commit flag
+    */
+
+   MSG_EXTRACT_STR (params_p, filename_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_INIT(*resp_p, _pmc_add_bin_expr_file_response_e);
+
+  /* Try to open the binary file to read the records from. */
+   binFile_p = fopen(filename_p, "r");
+
+   if (binFile_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not open file ->%s<-.  %s\n", 
+                filename_p,
+                strerror(errno));
+
+      MSG_ADD_UINT32_FIELD(*resp_p, pmc_open_file_fail_e);
+      MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+      free(info_msg_p);
+      return 0;
+   }
+ 
+   /* Read the expression records from the file and add them to the LL
+    * and PMCD DBs. */
+   while (true)
+   {
+      /* Read the record type. */
+      readNum = fread(&recordType, sizeof(recordType), 1, binFile_p);
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) == 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+            status = pmc_record_read_fail_e;
+         }
+         break;
+      }
+      else
+      {
+         /* Make sure this is an expression record. */
+         if (PMP_PMHWTOHL(recordType) != PM_COMPILED_REGEX_RECORD_TYPE)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to read a record from a binary file.  The "
+                            "record has an unexpected record type of %#x.\n", 
+                            PMP_PMHWTOHL(recordType));
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      }
+      
+      /* Read the expression record version. */
+      readNum = fread(&recordVersion, sizeof(recordVersion), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+      recordVersion = PMP_PMHWTOHL(recordVersion);
+      /* Check if the read regex record version is as we expect it to
+       * be. Currently these version are supported: 
+       * PM_REGEX_BIN_RECORD_V_1_0_1 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_0 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_1 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_0 + PM_SI_VERSION_1_0 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_1 + PM_SI_VERSION_1_0 */
+      if (PM_REGEX_BIN_RECORD_V_1_0_1 != recordVersion &&
+          PM_REGEX_BIN_RECORD_V_2_0_0 != recordVersion)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported binary regex record version of "
+                         "%d.%d.%d\n",
+                         recordVersion >> 16, 
+                         (recordVersion >> 8) & 0xff,
+                         recordVersion & 0xff);
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      if (recordVersion == PM_REGEX_BIN_RECORD_V_2_0_0)
+      {
+         /* With PM_REGEX_BIN_RECORD_V_2_0_0, two more fields pmeVersion and 
+          * siliconVersion are being read here. */
+         readNum = fread(&pmeVersion, sizeof(pmeVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         pmeVersion = PMP_PMHWTOHL(pmeVersion);
+
+         readNum = fread(&siliconVersion, sizeof(siliconVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         siliconVersion = PMP_PMHWTOHL(siliconVersion);
+      }
+      else
+      {
+         /* PM_REGEX_BIN_RECORD_V_1_0_1 - only for PME 1.1, Si 1.0. */
+         pmeVersion     = PM_PME_VERSION_1_1;
+         siliconVersion = PM_SI_VERSION_1_0;
+      }
+      
+#ifdef PME_1_1
+      if (pmeVersion != PM_PME_VERSION_1_1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported PME version of %d.%d\n",
+                         pmeVersion >> 8,
+                         pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+      
+      /* Only PME 1.1 silicon version 1.0 and 1.1 are supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0 &&
+          siliconVersion != PM_SI_VERSION_1_1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported silicon version of %d.%d\n",
+                         siliconVersion >> 8,
+                         siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+
+      if (pmcdDb_p->option8572rev1_0 && PM_SI_VERSION_1_0 != siliconVersion)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found incompatible silicon version of "
+                         "%d.%d when %s option is enabled.\n",
+                         siliconVersion >> 8,
+                         siliconVersion & 0xff,
+                         _PMCD_CMD_ARG_8572_REV_1_0);
+         status = pmc_incompatible_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_0
+      if (pmeVersion != PM_PME_VERSION_2_0)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported PME version of %d.%d\n",
+                         pmeVersion >> 8,
+                         pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.0 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported silicon version of %d.%d\n",
+                         siliconVersion >> 8,
+                         siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_1
+      if (pmeVersion != PM_PME_VERSION_2_1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported PME version of %d.%d\n",
+                         pmeVersion >> 8,
+                         pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.1 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Found unsupported silicon version of %d.%d\n",
+                         siliconVersion >> 8,
+                         siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+
+      /* Read the expression name length. */
+      readNum = fread(&expNameLength, sizeof(expNameLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      expNameLength = PMP_PMHWTOHL(expNameLength);
+      
+      /* Read the expression name. */
+      if (expNameString_p != NULL)
+      {
+         free(expNameString_p);
+      }
+
+      expNameString_p = calloc(1, expNameLength);
+
+      if (expNameString_p == NULL)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         FAILERROR_S,
+                         strerror(errno));
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      readNum = fread(expNameString_p, expNameLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+  
+      /* Read the expression string length. */
+      readNum = fread(&expStringLength, sizeof(expStringLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      expStringLength = PMP_PMHWTOHL(expStringLength);
+      
+      /* Read the expression string. */
+      if (expString_p != NULL)
+      {
+         free(expString_p);
+      }
+
+      expString_p = calloc(1, expStringLength);
+
+      if (expString_p == NULL)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Failed to allocate %u bytes of memory needed to "
+                         "read the expression string for the \"%s\" expression.\n", 
+                         expStringLength,
+                         expNameString_p);
+         status = pmc_no_memory_e;
+         break;
+      }
+
+      readNum = fread(expString_p, expStringLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+      
+      /* Read the option string length. */
+      readNum = fread(&optionStringLength,
+                      sizeof(optionStringLength),
+                      1, 
+                      binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      optionStringLength = PMP_PMHWTOHL(optionStringLength);
+      
+      /* Read the option string. */
+      if (optionString_p != NULL)
+      {
+         free(optionString_p);
+      }
+
+      optionString_p = calloc(1, optionStringLength);
+
+      if (optionString_p == NULL)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Failed to allocate %u bytes of memory needed to "
+                         "read the option string for the \"%s\" expression.\n", 
+                         optionStringLength,
+                         expNameString_p);
+         status = pmc_no_memory_e;
+         break;
+      }
+
+      readNum = fread(optionString_p, optionStringLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+  
+      /* Read the number of patterns. */
+      readNum = fread(&patternsNum, sizeof(patternsNum), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            EOFERROR_S);
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            FAILERROR_S,
+                            strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      patternsNum = PMP_PMHWTOHL(patternsNum);
+  
+      currentPattern_p  = &(exp.patterns);
+      previousPattern_p = NULL;
+  
+      currentPattern_p->nextPatternRecord_p = NULL;
+  
+      /* Read in each pattern */
+      cleanup = 0;
+  
+      for (count = 0; count < patternsNum; count++)
+      {
+         /* The expression record already contains 1 pattern record. If
+          * there is more than one pattern we need to allocate a new
+          * pattern record. */
+         if (count > 0)
+         {
+            currentPattern_p = (pm_pattern_record_t *) calloc(sizeof(pm_pattern_record_t), 1);
+
+            if (currentPattern_p == NULL)
+            {
+               cleanup = 1;
+               status = pmc_no_memory_e;
+               break;
+            }
+            previousPattern_p->nextPatternRecord_p = currentPattern_p;
+         }
+         
+         /* Read the size of the key element entry. */
+         readNum = fread(&keyElementEntrySize,
+                         sizeof(keyElementEntrySize),
+                         1, 
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+
+         keyElementEntrySize = PMP_PMHWTOHL(keyElementEntrySize);
+
+         if (keyElementEntrySize > sizeof(currentPattern_p->keyElementEntry))
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                     strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                     "Failed to read the key element entry for expression "
+                     "with name %s.  The size of the key element entry is %u which "
+                     "is longer than the expected maximum size of %Zd.\n", 
+                     expNameString_p,
+                     keyElementEntrySize, 
+                     sizeof(currentPattern_p->keyElementEntry));
+            cleanup = 1;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+          
+         /* Read the key element entry. */
+         readNum = fread(&(currentPattern_p->keyElementEntry), 
+                         keyElementEntrySize,
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+      
+         /* Read the size of the confirmation entry. */
+         readNum = fread(&confirmationEntrySize,
+                         sizeof(confirmationEntrySize), 
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+
+         confirmationEntrySize = PMP_PMHWTOHL(confirmationEntrySize);
+
+         if (confirmationEntrySize > 
+             sizeof(currentPattern_p->confirmationEntry))
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to read the confirmation entry for "
+                            "expression with name %s.  The size of the confirmation "
+                            "entry is %u which is longer than the expected maximum "
+                            "size of %Zd.\n",
+                            expNameString_p,
+                            confirmationEntrySize, 
+                            sizeof(currentPattern_p->confirmationEntry));
+            cleanup = 1;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      
+         /* Read the confirmation entry. */
+         readNum = fread(&(currentPattern_p->confirmationEntry), 
+                         confirmationEntrySize,
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               EOFERROR_S);
+            }
+            else
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               FAILERROR_S,
+                               strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+      
+         /* Check if some of the parameters are not too long for the PMCD
+          * and LL limits. */
+         if (expNameLength > sizeof(exp.name_s))
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add an expression record.  Expression name "
+                            "length of %u bytes is larger than the LL maximum supported "
+                            "size of %Zd.\n",
+                            expNameLength,
+                            sizeof(exp.name_s));
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+         else
+         {
+            memcpy(&exp.name_s, expNameString_p, expNameLength);
+
+            if (exp.name_s[expNameLength - 1] != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                               "Failed to add an expression record.  Found an "
+                               "expression with name that is not NULL terminated.\n");
+               cleanup = 1;
+               status = pmc_record_add_fail_e;
+               break;
+            }
+         }
+
+         if (expStringLength > _PMCD_EXP_STRING_MAX_SIZE)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add an expression record with name "
+                            "\"%s\".  Expression string length of %u bytes is larger "
+                            "than the PMCD maximum supported size of %u.\n",
+                            exp.name_s, 
+                            expStringLength,
+                            _PMCD_EXP_STRING_MAX_SIZE);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (expString_p[expStringLength - 1] != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add an expression record with name "
+                            "\"%s\".  Expression string in this record is not NULL "
+                            "terminated.\n",
+                            exp.name_s);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (optionStringLength > _PMCD_EXP_OPTIONS_STRING_MAX_SIZE)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add an expression record with name "
+                            "\"%s\".  Expression option length of %u bytes is larger "
+                            "than the PMCD maximum supported size of %u.\n",
+                            exp.name_s,
+                            expStringLength,
+                            _PMCD_EXP_OPTIONS_STRING_MAX_SIZE);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (optionString_p[optionStringLength - 1] != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add an expression record with name "
+                            "\"%s\".  Options string in this record is not NULL "
+                            "terminated.\n",
+                            exp.name_s);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+   
+         previousPattern_p = currentPattern_p;
+      }
+  
+      /* Check if we exited abnormally from reading the patterns */
+      if (cleanup)
+      {
+         /* Free any pattern objects that were created. */
+   
+         while (exp.patterns.nextPatternRecord_p != NULL)
+         {
+            currentPattern_p = exp.patterns.nextPatternRecord_p;
+    
+            exp.patterns.nextPatternRecord_p = (exp.patterns.nextPatternRecord_p)->nextPatternRecord_p;
+    
+            free(currentPattern_p);
+         }
+         break;
+      }
+  
+      /* Attempt to add the read regex record to the PMLL DB. */
+      pmllStatus = pmll_exp_add(llDbHandle,
+                                PMLL_EXP_RECORD_V_1_0_1, 
+                                (pm_exp_record_t *)&exp,
+                                &llIndex);
+
+  
+      /* Get set and subset information. */
+      _pm_confirmation_entry_t *conf_p = (_pm_confirmation_entry_t *)&(exp.patterns.confirmationEntry);
+      uint8_t                   set    = (conf_p->headTestLine).set;
+      uint16_t                  subset = (conf_p->headTestLine).subsetMask;
+
+      if (pmllStatus == pmll_ok_e)
+      {
+         addedExpCount++;
+
+         /* Add the regex to the PMCD DB. */
+         if (_pmcd_exp_add(&info_msg_p,
+                           pmcdDb_p->expDbHandle,
+                           &exp,
+                           expString_p, 
+                           optionString_p,
+                           set,
+                           subset,
+                           llIndex) == NULL)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "Failed to add the \"%s\" expression to the PMCD DB.",
+                            exp.name_s);
+            status = pmc_record_add_fail_e;
+         }
+      }
+      else
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Failed to add regular expression with name "
+                         "\"%s\".  \"%s\"\n",
+                         exp.name_s, 
+                         pmll_error_string_get(pmllStatus));
+         failedExpCount++;
+         status = pmc_record_add_fail_e;
+      }
+  
+      /* Free any pattern objects that were created. */
+      while (exp.patterns.nextPatternRecord_p != NULL)
+      {
+         currentPattern_p = exp.patterns.nextPatternRecord_p;
+   
+         exp.patterns.nextPatternRecord_p = (exp.patterns.nextPatternRecord_p)->nextPatternRecord_p;
+   
+         free(currentPattern_p);
+      }
+   } /* while (true) */
+ 
+   
+   /* Free the expression and option string buffers. */
+   if (expString_p     != NULL) {free(expString_p);}
+   if (optionString_p  != NULL) {free(optionString_p);}
+   if (expNameString_p != NULL) {free(expNameString_p);}
+   
+   if (addedExpCount != 0)
+   {
+      if (addedExpCount == 1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Successfully added one regex to the PM DB "
+                         "with handle %u.\n",
+                         llDbHandle);
+      }
+      else
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Successfully added %u regexes to the PM DB with handle %u.\n",
+                         addedExpCount,
+                         llDbHandle);
+      }
+
+      if (auto_commit)
+      {
+         /* Do the commit */
+         pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "The commit failed with the following error: \"%s\".\n",
+                            pmll_error_string_get(pmllStatus));
+      
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                            "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }  
+
+   if (failedExpCount != 0)
+   {
+      if (failedExpCount == 1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Failed to add one regex to the PM DB with handle %u.\n",
+                         llDbHandle);
+      }
+      else
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE + 1,
+                         "Failed to add %u expressions to PM DB with handle %u.\n",
+                         failedExpCount,
+                         llDbHandle);
+      }
+   }
+
+   fclose(binFile_p);
+ 
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/*
+ * Allocate a PMCD rule record.
+ *
+ * param  reactionNum  Number of reactions in the rule to be allocated.
+ * retval              The pointer to the allocated record on success; NULL
+ *                     pointer otherwise.
+ */
+static _pmcd_rule_record_t *_pmcd_pmcd_rule_allocate(uint32_t  reactionNum)
+{
+   /* Allocate and clear a new rule record. */
+   _pmcd_rule_record_t *rule_p = calloc(1, sizeof(_pmcd_rule_record_t));
+ 
+   if (rule_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate memory for a new rule record.");
+      return NULL;
+   }
+   else
+   {
+      /* Allocate and clear memory for the names of the expressions in
+       * the rule. */
+      rule_p->reactionNames_p = calloc(reactionNum, sizeof(_pmcd_name_t));
+ 
+      if (rule_p->reactionNames_p == NULL)
+      {
+         LOG_PRINT("Failed to allocate memory for the expression name fields in a new rule record.");
+         free(rule_p);
+         return NULL;
+      }
+   }
+ 
+   return rule_p;
+} /* _pmcd_pmcd_rule_allocate */
+
+
+/*
+ * Free the memory used by the specified PMCD rule.
+ *
+ * param rule_p  Pointer to the rule to free.
+ */
+static void _pmcd_pmcd_rule_free(_pmcd_rule_record_t *rule_p)
+{
+   if (rule_p == NULL)
+   {
+      return;
+   }
+   
+   if (rule_p->reactionNames_p != NULL)
+   {
+      free(rule_p->reactionNames_p);
+   }
+       
+   free(rule_p);
+} /* _pmcd_pmcd_rule_free */
+
+/*
+ * Recursively free all the PM reaction entries in the passed chain.
+ *
+ * param reaction_p  Pointer to the first PM reaction entry in the chain.
+ */
+static void _pmcd_pm_rule_reaction_entry_free(pm_reaction_entry_t *pmReaction_p)
+{
+   if (pmReaction_p != NULL)
+   {
+      if (pmReaction_p->nextReactionEntry_p != NULL)
+      {
+         _pmcd_pm_rule_reaction_entry_free(pmReaction_p->nextReactionEntry_p);
+      }
+  
+      free(pmReaction_p);
+   }  
+} /* _pmcd_pm_rule_reaction_entry_free */
+
+/*
+ * Free the memory used by the specified PM rule.
+ *
+ * param rule_p  Pointer to the PM rule record to be deallocated.
+ */
+static void _pmcd_pm_rule_free(pm_rule_record_v_1_0_0_t *pmRule_p)
+{
+   if (pmRule_p != NULL)
+   {
+      if (pmRule_p->reactionEntry_p != NULL)
+      {
+         _pmcd_pm_rule_reaction_entry_free(pmRule_p->reactionEntry_p);
+      }
+             
+      /* Deallocate the rule record. */
+      free(pmRule_p);
+   }  
+} /* _pmcd_pm_rule_free */
+
+/* 
+ *  Allocates a new rule record and adds it to the PMCD rule DB.
+ *
+ * param  ruleDbHandle  DB handle to add the rule record to.
+ * param  pmRule_p      Data to initialize the new record with.
+ * param  llIndex       Linker-loader index to be stored in the new
+ *                      rule record.
+ * retval               Pointer to the newly created and added rule
+ *                      record on successs; NULL pointer otherwise.
+ */
+static _pmcd_rule_record_t *_pmcd_rule_add(const handle_t            ruleDbHandle,
+                                           pm_rule_record_v_1_0_0_t *pmRule_p,
+                                           const uint32_t            llIndex)
+{
+   /* Allocate a new rule record. */
+   _pmcd_rule_record_t *pmcdRule_p = _pmcd_pmcd_rule_allocate(pmRule_p->reactionNum);
+ 
+   if (pmcdRule_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate a new rule record.");
+      return NULL;
+   }
+   
+   /* Initialize the newly allocated PMCD rule record. */
+   /* Save the number of expressions in the rule. */
+   strncpy(pmcdRule_p->name_s, pmRule_p->name_s, _PMCD_NAME_STRING_MAX_SIZE);
+   pmcdRule_p->reactionNum = pmRule_p->reactionNum;
+ 
+   /* Save the names of all the expressions in the rule. */
+   pm_reaction_entry_t *reaction_p     = pmRule_p->reactionEntry_p;
+   _pmcd_name_t        *reactionName_p = pmcdRule_p->reactionNames_p;
+   uint32_t             i              = 0;
+ 
+   for (i = 0; i < pmRule_p->reactionNum; i++)
+   {
+      strncpy(reactionName_p[i], reaction_p->expName_s, PM_NAME_MAX_LENGTH - 1);
+      /* Move to the next expression in the rule. */
+      reaction_p = reaction_p->nextReactionEntry_p;
+   }
+ 
+   /* Save the LL index. */
+   pmcdRule_p->llIndex = llIndex;
+ 
+   /* Add the new rule record to the PMCD rule DB. */
+   uint32_t    pmcdIndex = IDX_NULL_INDEX;
+   db_status_t dbStatus  = db_record_add(ruleDbHandle,
+                                         pmRule_p->name_s, 
+                                         pmcdRule_p,
+                                         &pmcdIndex);
+   if (dbStatus != db_ok_e)
+   {
+      LOG_PRINT("Failed to add a new rule record to the PMCD rule DB.  \"%s\"\n",
+                db_error_string_get(dbStatus));
+      _pmcd_pmcd_rule_free(pmcdRule_p);
+      return NULL;
+   }
+ 
+   /* Store the PMCD index in the rule record. */
+   pmcdRule_p->pmcdIndex = pmcdIndex;
+ 
+   return pmcdRule_p;
+} /* _pmcd_rule_add */
+
+/* 
+ * Adds rules from the specified binary file.
+ */
+static int _pmcd_add_bin_rule_file(uint8_t  *params_p,
+                                   uint8_t **resp_p)
+{
+   char                     *filename_p            = NULL;
+   bool                      auto_commit           = false;
+   char                     *info_msg_p            = NULL;
+   FILE                     *binFile_p             = NULL;
+   uint32_t                  recordType            = 0;
+   uint32_t                  recordVersion         = 0;
+   uint32_t                  pmeVersion            = 0;
+   uint32_t                  siliconVersion        = 0;
+   uint32_t                  ruleNameLength        = 0;
+   size_t                    readNum               = 0;
+   uint32_t                  i                     = 0;
+   uint32_t                  addedRuleCount        = 0;
+   uint32_t                  failedRuleCount       = 0;
+   bool                      reactionsReadOk       = false;
+   bool                      tryToAddRule          = false;
+   pmll_status_t             pmllStatus            = pmll_ok_e;
+   uint32_t                  idx                   = 0;
+   char                     *ruleNameString_p      = NULL;
+   pm_rule_record_v_1_0_0_t *rule_p                = NULL;
+   _pmcd_db_t               *pmcdDb_p              = _pmcd_db_handle_sg;
+   unsigned int              llDbHandle            = pmcdDb_p->llDbHandle;
+   int                       status                = 0;
+    
+   /* 2 parameters:
+    *    - string -> file name
+    *    - bool   -> auto commit flag
+    */
+
+   MSG_EXTRACT_STR (params_p, filename_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_INIT(*resp_p, _pmc_add_bin_rule_file_response_e);
+
+   /* Try to open the binary file to read the records from. */
+   binFile_p = fopen(filename_p, "r");
+
+   if (binFile_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not open file ->%s<-.  %s\n", 
+                filename_p,
+                strerror(errno));
+
+      MSG_ADD_UINT32_FIELD(*resp_p, pmc_open_file_fail_e);
+      MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+      free(info_msg_p);
+      return 0;
+   }
+
+   /* Read the rule records from the file. */
+   while (true)
+   {
+      /* Allocate a rule record.  This record will be filled with the
+       * data read from the binary rule record, then added to the PMLL
+       * DB and then freed.  It is not optimal but it is simple. */
+      rule_p = (pm_rule_record_v_1_0_0_t *)calloc(1, sizeof(pm_rule_record_v_1_0_0_t));
+
+      if (rule_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  FAILERROR_S,
+                  strerror(errno));
+         status = pmc_no_memory_e;
+         break;
+      }
+      
+   
+      /* Read the record type. */
+      readNum = fread(&recordType, sizeof(recordType), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (0 == feof(binFile_p))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            status = pmc_record_read_fail_e;
+         }
+         break;
+      }
+      else
+      {
+         /* Make sure this is a rule record. */
+         if (PMP_PMHWTOHL(recordType) != PM_COMPILED_RULE_RECORD_TYPE)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read a record from a binary file.  The "
+                     "record has an unexpected record type of %#x.\n", 
+                     PMP_PMHWTOHL(recordType));
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      }
+      
+      /* Read the rule record version. */
+      readNum = fread(&recordVersion, sizeof(recordVersion), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      recordVersion = PMP_PMHWTOHL(recordVersion);
+      /* Check if the read rule record version is as we expect it to be,
+       * i.e., PM_RULE_BIN_RECORD_V_1_0_0. */
+      /* Check if the read rule record version is as we expect it to
+       * be. Currently these version are supported: 
+       * PM_RULE_BIN_RECORD_V_1_0_0
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_0 
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_0 + PM_SI_VERSION_1_0
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_1 + PM_SI_VERSION_1_0 */
+  
+      if (recordVersion != PM_RULE_BIN_RECORD_V_1_0_0 && 
+          recordVersion != PM_RULE_BIN_RECORD_V_2_0_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported binary rule record version of %#x.\n",
+                  recordVersion);
+        status = pmc_record_read_fail_e;
+        break;
+      }
+
+      if (recordVersion == PM_RULE_BIN_RECORD_V_2_0_0)
+      {
+         /* With PM_RULE_BIN_RECORD_V_2_0_0, two more fields pmeVersion and 
+          * siliconVersion are being read here. */
+         readNum = fread(&pmeVersion, sizeof(pmeVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         pmeVersion = PMP_PMHWTOHL(pmeVersion);
+
+         readNum = fread(&siliconVersion, sizeof(siliconVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         siliconVersion = PMP_PMHWTOHL(siliconVersion);
+      }
+      else
+      {
+         /* PM_RULE_BIN_RECORD_V_1_0_0 - only for PME 1.1, Si 1.0. */
+         pmeVersion     = PM_PME_VERSION_1_1;
+         siliconVersion = PM_SI_VERSION_1_0;
+      }
+      
+#ifdef PME_1_1
+      if (pmeVersion != PM_PME_VERSION_1_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 1.1 silicon version 1.0 is supported. */
+      if (PM_SI_VERSION_1_0 != siliconVersion)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_0
+      if (pmeVersion != PM_PME_VERSION_2_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+      /* Only PME 2.0 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_1
+      if (pmeVersion != PM_PME_VERSION_2_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.1 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+  
+      /* Read the rule name length. */
+      readNum = fread(&ruleNameLength, sizeof(ruleNameLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      ruleNameLength = PMP_PMHWTOHL(ruleNameLength);
+  
+      /* Read the rule name.  We read the entire name of the rule to be
+       * able to display it in case it is too long. */
+      if (ruleNameString_p != NULL)
+      {
+         free(ruleNameString_p);
+      }
+
+      ruleNameString_p = (char *)calloc(1, ruleNameLength);
+
+      if (ruleNameString_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  FAILERROR_S,
+                  strerror(errno));
+        status = pmc_no_memory_e;
+        break;
+      }
+
+      readNum = fread(ruleNameString_p, ruleNameLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      /* Check if the length of the rule name is not too long. */
+      if (ruleNameString_p[ruleNameLength - 1] != 0)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Found a rule with name that is not NULL terminated.\n");
+         status = pmc_record_add_fail_e;
+         tryToAddRule = false;
+      }
+
+      if (ruleNameLength > sizeof(rule_p->name_s))
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Failed to add a rule record with rule name \"%s\".  "
+                         "Rule name length of %u bytes is larger than the LL maximum "
+                         "supported size of %Zd.\n",
+                         ruleNameString_p,
+                         ruleNameLength,
+                         sizeof(rule_p->name_s));
+         status = pmc_record_add_fail_e;
+         tryToAddRule = false;
+      }
+      else
+      {
+         /* Copy the read rule name into the PMLL rule record. */
+         strncpy(rule_p->name_s, ruleNameString_p, ruleNameLength);
+
+         if (rule_p->name_s[PM_NAME_MAX_LENGTH - 1] != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "Found a rule with name that is not NULL "
+                            "terminated after being copied.\n");
+            status = pmc_record_add_fail_e;
+            tryToAddRule = false;
+         }
+      }
+      
+      /* Read the number of the reactions present in this rule. */
+      readNum = fread(&rule_p->reactionNum,
+                      sizeof(rule_p->reactionNum),
+                      1, 
+                      binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      rule_p->reactionNum = PMP_PMHWTOHL(rule_p->reactionNum);
+  
+      /* Now read all the reactions in this rule.  Also link these
+       * reactions together as required by the PMLL rule record. */
+      pm_reaction_entry_t **pointToThisReaction_p = &rule_p->reactionEntry_p;
+      uint32_t              eventType             = 0;
+      uint32_t              expNameLength         = 0;
+      char                 *expNameString_p       = NULL;
+      uint8_t              *reactionData_p        = NULL;
+      reactionsReadOk                             = true;
+      tryToAddRule                                = true;
+     
+      for (i = 0; i < rule_p->reactionNum; i++)
+      {
+         /* Allocate memory for this reaction. */
+         pm_reaction_entry_t *reaction_p = calloc(1, sizeof(pm_reaction_entry_t));
+
+         if (reaction_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_no_memory_e;
+            break;
+         }
+         else
+         {
+            *pointToThisReaction_p = reaction_p;
+         }
+       
+         /* Read the event type */
+         readNum = fread(&eventType, sizeof(eventType), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         reaction_p->reactionEventType = PMP_PMHWTOHL(eventType);
+   
+         /* Read the length of the expression name. */
+         readNum = fread(&expNameLength, sizeof(expNameLength), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         expNameLength = PMP_PMHWTOHL(expNameLength);
+
+         /* Read the name of the expression. */
+         if (expNameString_p != NULL)
+         {
+            free(expNameString_p);
+         }
+
+         expNameString_p = calloc(1, expNameLength);
+
+         if (expNameString_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_no_memory_e;
+            break;
+         }
+
+         readNum = fread(expNameString_p, expNameLength, 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+   
+         /* Check if the expression name is NULL terminated. */
+         if (expNameString_p[expNameLength - 1] != 0)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "Reaction %u in rule \"%s\" has expression name "
+                            "that is not NULL terminated.\n",
+                            i + 1,
+                            rule_p->name_s);
+            status = pmc_record_read_fail_e;
+            tryToAddRule = false;
+         }
+
+         /* Check if the length of the expression name is not too long. */
+         if (expNameLength > sizeof(reaction_p->expName_s))
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "Failed to add a rule record with rule name \"%s\".  "
+                            "A reaction refers to expression \"%s\" with name length "
+                            "of %u which is too big.  The maximum expression name "
+                            "length supported by LL is %Zd.\n",
+                            rule_p->name_s, 
+                            expNameString_p,
+                            expNameLength, 
+                            sizeof(reaction_p->expName_s));
+            status = pmc_record_read_fail_e;
+            tryToAddRule = false;
+         }
+         else
+         {
+            /* Copy the read expression name into the PMLL reaction record. */
+            strncpy(reaction_p->expName_s, expNameString_p, expNameLength);
+
+            if (reaction_p->expName_s[PM_NAME_MAX_LENGTH - 1] != 0)
+            {
+               _PMCD_CSNPRINTF(&info_msg_p,
+                               strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                               "Reaction %u in rule \"%s\" has expression name "
+                               "that is not NULL terminated after being copied.\n", 
+                               i + 1,
+                               rule_p->name_s);
+               status       = pmc_record_read_fail_e;
+               tryToAddRule = false;
+            }
+            else
+            {
+               /* Check if an exp. with the name just read exists in the LL
+                * DB.  Do it only for reactions with the pattern reaction
+                * event type. */
+               if (reaction_p->reactionEventType == pm_pattern_reaction_event_type_e)
+               {
+                  bool  nameIsInUse = false;
+
+                  pmllStatus = pmll_exp_name_in_use(pmcdDb_p->llDbHandle, 
+                                                    reaction_p->expName_s, 
+                                                    &nameIsInUse,
+                                                    NULL);
+
+                  if (pmllStatus != pmll_ok_e)
+                  {
+                     _PMCD_CSNPRINTF(&info_msg_p,
+                                     strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                                     "Failed to determine if expression \"%s\" "
+                                     "used by rule \"%s\" exists.  \"%s\"\n", 
+                                     reaction_p->expName_s,
+                                     rule_p->name_s,  
+                                     pmll_error_string_get(pmllStatus));
+                     status       = pmc_record_add_fail_e;
+                     tryToAddRule = false;
+                  }
+                  else if (nameIsInUse == false)
+                  {
+                     _PMCD_CSNPRINTF(&info_msg_p,
+                                     strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                                     "Cannot add rule with name \"%s\".  The rule "
+                                     "uses expression \"%s\" which is not defined.\n", 
+                                     rule_p->name_s,
+                                     reaction_p->expName_s);
+                     status       = pmc_record_add_fail_e;
+                     tryToAddRule = false;
+                  }
+               }
+            }
+         }
+         
+         /* Read the size of the reaction. */
+         readNum = fread(&reaction_p->reactionSize, 
+                         sizeof(reaction_p->reactionSize), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         reaction_p->reactionSize = PMP_PMHWTOHL(reaction_p->reactionSize);
+         
+         /* Read the reaction. */
+         if (reactionData_p != NULL)
+         {
+            free(reactionData_p);
+         }
+
+         reactionData_p = calloc(1, reaction_p->reactionSize);
+
+         if (reactionData_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         readNum = fread(reactionData_p, reaction_p->reactionSize, 1, 
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         if (reaction_p->reactionSize > sizeof(reaction_p->reactionData))
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "Failed to read a rule record.  Size of "
+                            "reaction for rule \"%s\" and expression \"%s\" of %u "
+                            "bytes is too big.  The maximum reaction size supported "
+                            "by LL is %Zd.\n",
+                            rule_p->name_s,
+                            reaction_p->expName_s, 
+                            reaction_p->reactionSize,
+                            sizeof(reaction_p->reactionData));
+            status       = EINVAL;
+            tryToAddRule = false;
+         }
+         else
+         {
+            /* Copy the read reaction data into the PMLL reaction record. */
+            memcpy(reaction_p->reactionData,
+                   reactionData_p, 
+                   reaction_p->reactionSize);
+         }
+   
+         /* Adjust the pointToThisReaction_p pointer. */
+         pointToThisReaction_p = &reaction_p->nextReactionEntry_p;
+      } /* for - read the expressions in the rule */
+  
+  
+      /* The rule has been read.  If the rule has been read successfully
+       * then the rule record has been created and is ready to be added
+       * to LL. */
+      if (reactionsReadOk == false)
+      {
+         /* We failed to read the rule.  We must bail out from reading
+          * the file. */
+         failedRuleCount++;
+         break;
+      }
+      
+      /* We read the rule successfully.  Check if we can add it to LL. */
+      if (tryToAddRule == true)
+      {
+         /* Add the rule to the linker-loader DB. */
+         pmllStatus = pmll_rule_add(pmcdDb_p->llDbHandle,
+                                    PMLL_RULE_RECORD_V_1_0_0,
+                                    (pm_rule_record_t *)rule_p,
+                                    &idx);
+
+         if (pmllStatus == pmll_ok_e)
+         {
+            addedRuleCount++;
+
+            /* Add the rule to the PMCD rule DB. */
+            if (_pmcd_rule_add(pmcdDb_p->ruleDbHandle, rule_p, idx) == NULL)
+            {
+               LOG_PRINT("Failed to add the \"%s\" rule to the PMCD DB.",
+                         rule_p->name_s);
+               status = pmc_record_add_fail_e;
+            }
+         }
+         else
+         {
+            LOG_PRINT("Failed to add a rule with name \"%s\".  \"%s\"\n",
+                      rule_p->name_s,
+                      pmll_error_string_get(pmllStatus));
+            status = pmc_record_add_fail_e;
+            failedRuleCount++;
+         }
+      }
+      else
+      {
+         /* We read the rule successfuly but the data read contained errors. */
+         failedRuleCount++;
+      }
+  
+      /* We are done with this rule.  Free all the allocated memory
+       * blocks used to add this rule.  If needed again they will be
+       * reallocated. */
+      if (rule_p != NULL)
+      { 
+         _pmcd_pm_rule_free(rule_p);
+         rule_p = NULL; 
+      }
+
+      if (ruleNameString_p != NULL)
+      { 
+         free(ruleNameString_p); 
+         ruleNameString_p = NULL; 
+      }
+
+      if (expNameString_p != NULL)
+      { 
+         free(expNameString_p); 
+         expNameString_p = NULL; 
+      }
+
+      if (reactionData_p != NULL)
+      {
+         free(reactionData_p); 
+         reactionData_p = NULL; 
+      }
+  
+      /* Check if we are not spinning in the while(true) loop. */
+      if (addedRuleCount > PM_STATEFUL_RULE_MAX_NUM_V2_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Bad logic in function or there are too many rules in "
+                  "the binary file.;  spinning in a while loop "
+                  "(addedRuleCount=%u, failedRuleCount=%u).", 
+                  addedRuleCount,
+                  failedRuleCount);
+        status = pmc_record_add_fail_e;
+        break;
+      }
+   } /* while - read all the rules from the binary file. */
+ 
+ 
+   /* We are done with the file.  Free all the allocated memory blocks. */
+   if (rule_p != NULL)
+   { 
+      free(rule_p); 
+      rule_p = NULL; 
+   }
+
+   if (ruleNameString_p != NULL)
+   { 
+      free(ruleNameString_p); 
+      rule_p = NULL; 
+   }
+ 
+   if (addedRuleCount != 0)
+   {
+      if (addedRuleCount == 1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Successfully added one rule to the PM DB with handle %u.\n",
+                         llDbHandle);
+      }
+      else
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Successfully added %u rules to the PM DB with handle %u.\n",
+                         addedRuleCount,
+                         llDbHandle);
+      }
+
+      if (auto_commit)
+      {
+         /* Do the commit */
+         pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "The commit failed with the following error: \"%s\".\n",
+                            pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+
+   if (failedRuleCount != 0)
+   {
+      if (failedRuleCount == 1)
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Failed to add one rule to the PM DB with handle %u.\n",
+                         llDbHandle);
+      }
+      else
+      {
+         _PMCD_CSNPRINTF(&info_msg_p,
+                         strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Failed to add %u rules to PM DB with handle %u.\n",
+                         failedRuleCount,
+                         llDbHandle);
+      }
+   }
+   
+   fclose(binFile_p);
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+} /* _pmcd_rules_from_bin_file_add */
+
+/*
+ * Delete a single rule from both the LL and PMCD DBs.
+ *
+ * param llDbHandle   Handle of the PMLL DB to use.
+ * param pmcdDbHandle Handle of the PMCD DB to use.
+ * param llIndex      LL index of the rule record to delete.
+ * param pmcdIndex    PMCD index of the rule record to delete.
+ * retval             "true" upon success, "false" otherwise.
+ */
+static bool _pmcd_rule_delete(unsigned int  llDbHandle,
+                              handle_t      pmcdDbHandle,
+                              uint32_t      llIndex,
+                              uint32_t      pmcdIndex)
+{
+   pmll_status_t        pmllStatus = pmll_ok_e;
+   bool                 status     = true;
+   _pmcd_rule_record_t *rule_p     = NULL;
+ 
+   /* Get the pointer to the rule record. */
+   rule_p = db_record_by_index_get(pmcdDbHandle, pmcdIndex);
+ 
+   if (rule_p == NULL)
+   {
+      LOG_PRINT("Rule with index %u does not exist.\n", pmcdIndex);
+      return (false);
+   }
+   
+   if (llIndex != pmcdIndex)
+   {
+      /* We can do this comparison since the same DB module is used by
+       * both PMCD and LL modules and the records are added and removed
+       * to/from both DBs at the same time. */
+      LOG_PRINT("LL and PMCD indexes are different (llIndex=%u, pmcdIndex=%u.\n",
+                llIndex,
+                pmcdIndex);
+      status = false;
+   }
+   else
+   {
+      /* Delete the rule from the LL database. */
+      pmllStatus = pmll_rule_delete(llDbHandle, llIndex);
+
+      if (pmllStatus != pmll_ok_e)
+      {
+         LOG_PRINT("Deleting rule with LL index=%u from the LL "
+                   "DB failed with the following error: \"%s\"\n", 
+                   llIndex,
+                   pmll_error_string_get(pmllStatus));
+         status = false;
+      }
+      else
+      {
+         /* Delete the rule from the PMCD rule DB. */
+         db_status_t dbStatus = db_record_by_index_delete(pmcdDbHandle, pmcdIndex);
+
+         if (dbStatus != db_ok_e)
+         {
+            LOG_PRINT("Failed to delete rule with index %u from the PMCD rule DB. %s\n",
+                      pmcdIndex,
+                      db_error_string_get(dbStatus));
+            status = false;
+         }
+      }
+   }
+ 
+   /* Free the rule record. */
+   _pmcd_pmcd_rule_free(rule_p);
+   
+   return status;
+} /* _pmcd_rule_delete */
+
+
+/*
+ * Delete a single expression from both the LL and PMCD DBs.
+ *
+ * param llDbHandle   Handle of the PMLL DB to use.
+ * param pmcdDbHandle Handle of the PMCD DB to use.
+ * param llIndex      LL index of the rule record to delete.
+ * param pmcdIndex    PMCD index of the rule record to delete.
+ * retval             "true" upon success, "false" otherwise.
+ */
+static bool _pmcd_exp_delete(char               **info_msg_p,
+                             unsigned int         llDbHandle,
+                             handle_t             pmcdDbHandle,
+                             _pmcd_exp_record_t  *rec_p)
+{
+   pmll_status_t     pmllStatus = pmll_ok_e;
+   bool              status     = true;
+   pm_exp_record_t  *exp_p      = NULL;
+   uint32_t          llIndex    = 0;
+   uint32_t          pmcdIndex  = 0;
+   dll_node_t       *dll_node_p = NULL;
+ 
+   if (rec_p == NULL)
+   {
+      LOG_PRINT("NULL record passed to _pmcd_exp_delete\n");
+      return (false);
+   }
+
+   llIndex    = rec_p->llIndex;
+   pmcdIndex  = rec_p->pmcdIndex;
+   dll_node_p = &(rec_p->dll_node);
+
+   /* Get the pointer to the expression record. */
+   exp_p = db_record_by_index_get(pmcdDbHandle, pmcdIndex);
+
+   if (exp_p == NULL)
+   {
+      LOG_PRINT("Expression with index %u does not exist.\n", pmcdIndex);
+      return (false);
+   }
+     
+   if (llIndex != pmcdIndex)
+   {
+      /* We can do this comparison since the same DB module is used by
+       * both PMCD and LL modules and the records are added and removed
+       * to/from both DBs at the same time. */
+      LOG_PRINT("LL and PMCD indexes are different (llIndex=%u, pmcdIndex=%u.\n",
+                llIndex,
+                pmcdIndex);
+      status = false;
+   }
+   else
+   {
+      /* Delete the expression from the LL database. */
+      pmllStatus = pmll_exp_delete(llDbHandle, llIndex);
+
+      if (pmllStatus != pmll_ok_e)
+      {
+         _PMCD_CSNPRINTF(info_msg_p,
+                         strlen(*info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                         "Deleting expression with LL index=%u from the LL "
+                         "DB failed with the following error: \"%s\"\n", 
+                         llIndex,
+                         pmll_error_string_get(pmllStatus));
+         status = false;
+      }
+      else
+      {
+         /* Delete the expression from the PMCD expression DB. */
+         db_status_t dbStatus = db_record_by_index_delete(pmcdDbHandle, pmcdIndex);
+
+         if (dbStatus != db_ok_e)
+         {
+            _PMCD_CSNPRINTF(info_msg_p,
+                            strlen(*info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "Failed to delete expression with index %u from the PMCD "
+                            "expression DB. %s\n",
+                            pmcdIndex,
+                            db_error_string_get(dbStatus));
+            status = false;
+         }
+         else
+         {
+            /* Remove this record from the set list */
+            dll_remove_node(dll_node_p);
+
+            /* Free the expression record. */
+            free(exp_p);
+         }
+      }
+   }
+
+   return status;
+} /* _pmcd_exp_delete */
+
+/*
+ * Delete all the expressions in the PMCD and PMLL DBs.
+ *
+ * param pmcdDbHandle   Handle of the PMCD DB to use.
+ * retval               0 upon success, an error code otherwise.
+ */
+static int _pmcd_exp_all_delete(char     **info_msg_p,
+                                handle_t   pmcdDbHandle)
+{
+   uint32_t            pmcdExpIndex = IDX_NULL_INDEX;
+   _pmcd_exp_record_t *exp_p        = NULL;
+   uint32_t            counter      = 0;
+   _pmcd_db_t         *pmcdDb_p     = pmcdDbHandle;
+   bool                boolStatus   = true;
+   int                 status       = 0;
+   
+ 
+   while ((exp_p = db_record_next_get(pmcdDb_p->expDbHandle, 
+                                      &pmcdExpIndex)) != NULL)
+   {
+      pmcdExpIndex = exp_p->pmcdIndex;
+
+      boolStatus = _pmcd_exp_delete(info_msg_p,
+                                    pmcdDb_p->llDbHandle,
+                                    pmcdDb_p->expDbHandle, 
+                                    exp_p);
+      if (boolStatus == false)
+      {
+         status = EIO;
+      }
+
+      counter++;
+
+#ifdef PME_1_1
+      if (counter > PM_PATTERN_MAX_NUM_V1)
+#else
+#ifdef PME_2_0
+      if (counter > PM_PATTERN_MAX_NUM_V2_0)
+#else
+#ifdef PME_2_1
+      if (counter > PM_PATTERN_MAX_NUM_V2_1)
+#else
+      // Stop the compile! No valid PME version specified.
+      INVALID
+#endif // PME_2_1
+#endif // PME_2_0
+#endif // PME_1_1
+      {
+         LOG_PRINT("Must break from delete all expression loop. Max exps exceeded!\n");
+         break;
+      }
+   } /* while - for all expressions in the DB */
+ 
+   return status;
+} /* _pmcd_exp_all_delete */
+
+/*
+ * Delete all the rules in the PMCD and PMLL DBs.
+ *
+ * param pmcdDbHandle   Handle of the PMCD DB to use.
+ * retval               0 upon success, an error code otherwise.
+ */
+static int _pmcd_rule_all_delete(handle_t pmcdDbHandle)
+{
+   uint32_t             pmcdRuleIndex = IDX_NULL_INDEX;
+   _pmcd_rule_record_t *rule_p        = NULL;
+   uint32_t             counter       = 0;
+   _pmcd_db_t          *pmcdDb_p      = pmcdDbHandle;
+   bool                 boolStatus    = true;
+   int                  status        = 0;
+ 
+   while ((rule_p = db_record_next_get(pmcdDb_p->ruleDbHandle, 
+                                       &pmcdRuleIndex)) != NULL)
+   {
+      pmcdRuleIndex = rule_p->pmcdIndex;
+
+      boolStatus = _pmcd_rule_delete(pmcdDb_p->llDbHandle,
+                                     pmcdDb_p->ruleDbHandle, 
+                                     rule_p->llIndex,
+                                     rule_p->pmcdIndex);
+      if (boolStatus == false)
+      {
+         status = EIO;
+      }
+
+      counter++;
+
+#ifdef PME_1_1
+      if (counter > PM_STATEFUL_RULE_MAX_NUM_V1)
+#else
+#ifdef PME_2_0
+      if (counter > PM_STATEFUL_RULE_MAX_NUM_V2_0)
+#else
+#ifdef PME_2_1
+      if (counter > PM_STATEFUL_RULE_MAX_NUM_V2_1)
+#else
+      // Stop the compile! No valid PME version specified.
+      INVALID
+#endif // PME_2_1
+#endif // PME_2_0
+#endif // PME_1_1
+      {
+          LOG_PRINT("Must break from delete all rule loop. Max rules exceeded!\n");
+         break;
+      }
+   } /* while - for all expressions in the DB */
+ 
+   return status;
+} /* _pmcd_rule_all_delete */
+
+/* -------------------------------------------------------------------------- *
+ * Delete all expressions.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_all_expr(uint8_t  *params_p,
+                              uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val     = 0;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_all_expr_response_e);
+
+   /* Do the delete */
+   ret_val = _pmcd_exp_all_delete(&info_msg_p,
+                                  _pmcd_db_handle_sg);
+
+   if (ret_val != 0)
+   {
+      _PMCD_CSNPRINTF(&info_msg_p,
+                      strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                      "Could not delete all expressions.\n");
+
+      status = pmc_delete_fail_e;
+   }
+   else
+   {
+      _PMCD_CSNPRINTF(&info_msg_p,
+                      strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                      "All expressions deleted successfully.\n");
+
+      status = pmc_ok_e;
+
+      if (auto_commit)
+      {
+         _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+         /* Do the commit */
+         pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "The commit failed with the following error: \"%s\".\n",
+                            pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            _PMCD_CSNPRINTF(&info_msg_p,
+                            strlen(info_msg_p) + _PMC_MAX_ERROR_MSG_SIZE,
+                            "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Delete all rules.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_all_rule(uint8_t  *params_p,
+                              uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val     = 0;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_all_expr_response_e);
+
+   /* Do the delete */
+   ret_val = _pmcd_rule_all_delete(_pmcd_db_handle_sg);
+
+   if (ret_val != 0)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not delete all rules.\n");
+
+      status = pmc_delete_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "All rules deleted successfully.\n");
+
+      status = pmc_ok_e;
+  
+      if (auto_commit)
+      {
+         _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+         /* Do the commit */
+         pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit failed with the following error: \"%s\".\n",
+                     pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Delete all expressions and rules.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_all(uint8_t  *params_p,
+                         uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val_r   = 0;
+   int            ret_val_e   = 0;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_all_expr_response_e);
+
+   /* Do the delete */
+   ret_val_r = _pmcd_rule_all_delete(_pmcd_db_handle_sg);
+   ret_val_e = _pmcd_exp_all_delete(&info_msg_p,
+                                    _pmcd_db_handle_sg);
+
+   if (ret_val_r != 0 && ret_val_e != 0)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not delete all rules and could not delete all expressions.\n");
+
+      status = pmc_delete_fail_e;
+   }
+   else
+   {
+      if (ret_val_r != 0 && ret_val_e == 0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete all rules, but all expressions deleted successfully.\n");
+
+         status = pmc_delete_fail_e;
+      }
+      else if (ret_val_r == 0 && ret_val_e != 0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete all expressions, but all rules deleted successfully.\n");
+
+         status = pmc_delete_fail_e;
+      }
+      else
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "All rules and expressions deleted successfully.\n");
+
+         status = pmc_ok_e;
+      }
+
+      if (auto_commit)
+      {
+         _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+         /* Do the commit */
+         pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit failed with the following error: \"%s\".\n",
+                     pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/*
+ * Delete a named expression in the PMCD and PMLL DBs.
+ *
+ * param pmcdDbHandle   Handle of the PMCD DB to use.
+ * param name_p         Name of the expression.
+ *
+ * retval               0 upon success, an error code otherwise.
+ */
+static int _pmcd_exp_name_delete(char     **info_msg_p,
+                                 handle_t   pmcdDbHandle,
+                                 char      *name_p)
+{
+   _pmcd_exp_record_t *exp_p        = NULL;
+   _pmcd_db_t         *pmcdDb_p     = pmcdDbHandle;
+   bool                boolStatus   = true;
+   
+   exp_p = db_record_by_name_get(pmcdDb_p->expDbHandle, name_p); 
+
+   if (exp_p == NULL)
+   {
+      return EINVAL;
+   }
+
+   boolStatus = _pmcd_exp_delete(info_msg_p,
+                                 pmcdDb_p->llDbHandle,
+                                 pmcdDb_p->expDbHandle, 
+                                 exp_p);
+   if (boolStatus == false)
+   {
+      return EIO;
+   }
+
+   return 0;
+} /* _pmcd_exp_name_delete */
+
+/*
+ * Delete expressions with a given set and subset from the PMCD and PMLL DBs.
+ *
+ * param pmcdDbHandle   Handle of the PMCD DB to use.
+ * param set            Set number.
+ * param subset         Subset number. -1 indicates all subsets.
+ *
+ * retval               0 upon success, an error code otherwise.
+ */
+static int _pmcd_exp_set_delete(char      **info_msg_p,
+                                handle_t    pmcdDbHandle,
+                                uint8_t     set,
+                                uint16_t    subset)
+{
+   _pmcd_exp_record_t *exp_p        = NULL;
+   _pmcd_db_t         *pmcdDb_p     = pmcdDbHandle;
+   bool                boolStatus   = true;
+   dll_list_t         *set_list_p   = NULL;
+   dll_node_t         *node_p       = NULL;
+   uint32_t            list_size    = 0;
+   
+   set_list_p = &(pmcdDb_p->set[set]);
+
+   list_size = (uint32_t)dll_count(set_list_p);
+
+   /* Go through the list for the appropriate set and make sure the subset
+    * matches. 
+    */
+   node_p = dll_get_first(set_list_p);
+
+   while (node_p != NULL)
+   {
+      exp_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                       _pmcd_exp_record_t,
+                                       dll_node);
+
+      if ((exp_p->subset & subset) > 0)
+      {
+         boolStatus = _pmcd_exp_delete(info_msg_p,
+                                       pmcdDb_p->llDbHandle,
+                                       pmcdDb_p->expDbHandle, 
+                                       exp_p);
+
+         if (boolStatus == false)
+         {
+            return EIO;
+         }
+      }
+
+      /* Deleting the expression removes it from the set list, so
+       * to get the next one, get the new first node.
+       */
+      node_p = dll_get_first(set_list_p);
+   }
+
+   return 0;
+} /* _pmcd_exp_set_delete */
+
+/*
+ * Delete a named rule in the PMCD and PMLL DBs.
+ *
+ * param pmcdDbHandle   Handle of the PMCD DB to use.
+ * param name_p         Name of the rule.
+ *
+ * retval               0 upon success, an error code otherwise.
+ */
+static int _pmcd_rule_name_delete(handle_t  pmcdDbHandle,
+                                  char     *name_p)
+{
+   _pmcd_rule_record_t *rule_p       = NULL;
+   _pmcd_db_t          *pmcdDb_p     = pmcdDbHandle;
+   bool                 boolStatus   = true;
+   
+   rule_p = db_record_by_name_get(pmcdDb_p->ruleDbHandle, name_p);
+
+   if (rule_p == NULL)
+   {
+      return EINVAL;
+   }
+
+   boolStatus = _pmcd_rule_delete(pmcdDb_p->llDbHandle,
+                                  pmcdDb_p->ruleDbHandle, 
+                                  rule_p->llIndex,
+                                  rule_p->pmcdIndex);
+   if (boolStatus == false)
+   {
+      return EIO;
+   }
+
+   return 0;
+} /* _pmcd_rule_name_delete */
+
+/* -------------------------------------------------------------------------- *
+ * Delete an expression with a given name.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_expr_name(uint8_t  *params_p,
+                               uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val     = 0;
+   char          *name_p      = NULL;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_STR (params_p, name_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_expr_name_response_e);
+
+   /* Do the delete */
+   ret_val = _pmcd_exp_name_delete(&info_msg_p,
+                                   _pmcd_db_handle_sg,
+                                   name_p);
+
+   switch (ret_val)
+   {
+      case 0:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Expression named ->%s<- deleted successfully.\n",
+                  name_p);
+
+         status = pmc_ok_e;
+
+         if (auto_commit)
+         {
+            _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+            /* Do the commit */
+            pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+            if (pmllStatus != pmll_ok_e)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit failed with the following error: \"%s\".\n",
+                        pmll_error_string_get(pmllStatus));
+   
+               status = pmc_commit_fail_e;
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit was successful.\n");
+      
+               status = pmc_ok_e;
+            }
+         }
+
+         break;
+
+      case EINVAL:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete expression with name ->%s<-. No expression with that name found.\n",
+                  name_p);
+
+         status = pmc_delete_fail_e;
+         break;
+
+      case EIO:
+      default:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete expression with name ->%s<-.\n",
+                  name_p);
+
+         status = pmc_delete_fail_e;
+         break;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Delete an expression with a given set and subset.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_expr_set(uint8_t  *params_p,
+                              uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val     = 0;
+   uint8_t        set         = 0;
+   uint16_t       subset      = 0xffff;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_UINT8 (params_p, set);
+   MSG_EXTRACT_UINT16(params_p, subset);
+   MSG_EXTRACT_BOOL  (params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_expr_set_response_e);
+
+   /* Do the delete */
+   ret_val = _pmcd_exp_set_delete(&info_msg_p,
+                                  _pmcd_db_handle_sg,
+                                  set,
+                                  subset);
+
+   switch (ret_val)
+   {
+      case 0:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Expressions with set %d and subset %d deleted successfully.\n",
+                  set,
+                  subset);
+
+         status = pmc_ok_e;
+
+         if (auto_commit)
+         {
+            _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+            /* Do the commit */
+            pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+            if (pmllStatus != pmll_ok_e)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit failed with the following error: \"%s\".\n",
+                        pmll_error_string_get(pmllStatus));
+   
+               status = pmc_commit_fail_e;
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit was successful.\n");
+      
+               status = pmc_ok_e;
+            }
+         }
+
+         break;
+
+      case EINVAL:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete expressions with set %d and subset %d. No expressions with those parameters found.\n",
+                  set,
+                  subset);
+
+         status = pmc_delete_fail_e;
+         break;
+
+      case EIO:
+      default:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete expressions with set %d and subset %d.\n",
+                  set,
+                  subset);
+
+         status = pmc_delete_fail_e;
+         break;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Delete a rule with a given name.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_rule_name(uint8_t  *params_p,
+                               uint8_t **resp_p)
+{
+   pmc_status_t   status      = pmc_ok_e;
+   char          *info_msg_p  = NULL;
+   int            ret_val     = 0;
+   char          *name_p      = NULL;
+   bool           auto_commit = false;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_STR (params_p, name_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_del_rule_name_response_e);
+
+   /* Do the delete */
+   ret_val = _pmcd_rule_name_delete(_pmcd_db_handle_sg,
+                                    name_p);
+
+   switch (ret_val)
+   {
+      case 0:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Rule named ->%s<- deleted successfully.\n",
+                  name_p);
+
+         status = pmc_ok_e;
+
+         if (auto_commit)
+         {
+            _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+            /* Do the commit */
+            pmll_status_t pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+            if (pmllStatus != pmll_ok_e)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit failed with the following error: \"%s\".\n",
+                        pmll_error_string_get(pmllStatus));
+      
+               status = pmc_commit_fail_e;
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "The commit was successful.\n");
+      
+               status = pmc_ok_e;
+            }
+         }
+
+         break;
+
+      case EINVAL:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete rule with name ->%s<-. No rule found with that name.\n",
+                  name_p);
+
+         status = pmc_delete_fail_e;
+         break;
+
+      case EIO:
+      default:
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Could not delete rule with name ->%s<-.\n",
+                  name_p);
+
+         status = pmc_delete_fail_e;
+         break;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Delete binary expression file.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_del_bin_expr_file(uint8_t  *params_p,
+                                   uint8_t **resp_p)
+{
+   char                    *filename_p;
+   bool                     auto_commit;
+   FILE                    *binFile_p;
+   pm_exp_record_v_1_0_1_t  exp;
+   pm_pattern_record_t     *currentPattern_p      = NULL;
+   pm_pattern_record_t     *previousPattern_p     = NULL;
+   uint32_t                 recordType            = 0;
+   uint32_t                 recordVersion         = 0;
+   uint32_t                 pmeVersion            = 0;
+   uint32_t                 siliconVersion        = 0;
+   uint32_t                 expNameLength         = 0;
+   uint32_t                 expStringLength       = 0;
+   uint32_t                 optionStringLength    = 0;
+   uint32_t                 patternsNum           = 0;
+   uint32_t                 count                 = 0;
+   uint32_t                 keyElementEntrySize   = 0;
+   uint32_t                 confirmationEntrySize = 0;
+   size_t                   readNum               = 0;
+   pmll_status_t            pmllStatus            = pmll_ok_e;
+   uint32_t                 failedExpCount        = 0;
+   uint32_t                 deletedExpCount       = 0;
+   char                    *expString_p           = NULL;
+   char                    *optionString_p        = NULL;
+   char                    *expNameString_p       = NULL;
+   uint32_t                 cleanup               = 0;
+   pmc_status_t             status                = pmc_ok_e;
+   char                    *info_msg_p            = NULL;
+   int                      ret_val               = 0;
+   _pmcd_db_t              *pmcdDb_p              = _pmcd_db_handle_sg;
+
+   /* 2 parameters:
+    *    - string -> file name
+    *    - bool   -> auto commit flag
+    */
+
+   MSG_EXTRACT_STR (params_p, filename_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_INIT(*resp_p, _pmc_del_bin_expr_file_response_e);
+
+   /* Try to open the binary file to read the records from. */
+   binFile_p = fopen(filename_p, "r");
+
+   if (binFile_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not open file ->%s<-.  %s\n", 
+                filename_p,
+                strerror(errno));
+
+      MSG_ADD_UINT32_FIELD(*resp_p, pmc_open_file_fail_e);
+      MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+      free(info_msg_p);
+      return 0;
+   }
+ 
+   /* Read the expression records from the file and add them to the LL
+    * and PMCD DBs. */
+   while (true)
+   {
+      /* Read the record type. */
+      readNum = fread(&recordType, sizeof(recordType), 1, binFile_p);
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) == 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            status = pmc_record_read_fail_e;
+         }
+         break;
+      }
+      else
+      {
+         /* Make sure this is an expression record. */
+         if (PMP_PMHWTOHL(recordType) != PM_COMPILED_REGEX_RECORD_TYPE)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read a record from a binary file.  The "
+                     "record has an unexpected record type of %#x.\n", 
+                     PMP_PMHWTOHL(recordType));
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      }
+      
+      /* Read the expression record version. */
+      readNum = fread(&recordVersion, sizeof(recordVersion), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+      recordVersion = PMP_PMHWTOHL(recordVersion);
+      /* Check if the read regex record version is as we expect it to
+       * be. Currently these version are supported: 
+       * PM_REGEX_BIN_RECORD_V_1_0_1 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_0 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_1 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_0 + PM_SI_VERSION_1_0 
+       * PM_REGEX_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_1 + PM_SI_VERSION_1_0 */
+      if (PM_REGEX_BIN_RECORD_V_1_0_1 != recordVersion &&
+          PM_REGEX_BIN_RECORD_V_2_0_0 != recordVersion)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported binary regex record version of "
+                  "%d.%d.%d\n",
+                  recordVersion >> 16, 
+                  (recordVersion >> 8) & 0xff,
+                  recordVersion & 0xff);
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      if (recordVersion == PM_REGEX_BIN_RECORD_V_2_0_0)
+      {
+         /* With PM_REGEX_BIN_RECORD_V_2_0_0, two more fields pmeVersion and 
+          * siliconVersion are being read here. */
+         readNum = fread(&pmeVersion, sizeof(pmeVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         pmeVersion = PMP_PMHWTOHL(pmeVersion);
+
+         readNum = fread(&siliconVersion, sizeof(siliconVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         siliconVersion = PMP_PMHWTOHL(siliconVersion);
+      }
+      else
+      {
+         /* PM_REGEX_BIN_RECORD_V_1_0_1 - only for PME 1.1, Si 1.0. */
+         pmeVersion     = PM_PME_VERSION_1_1;
+         siliconVersion = PM_SI_VERSION_1_0;
+      }
+      
+#ifdef PME_1_1
+      if (pmeVersion != PM_PME_VERSION_1_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+      
+      /* Only PME 1.1 silicon version 1.0 and 1.1 are supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0 &&
+          siliconVersion != PM_SI_VERSION_1_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                   siliconVersion >> 8,
+                   siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+
+      if (pmcdDb_p->option8572rev1_0 && PM_SI_VERSION_1_0 != siliconVersion)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found incompatible silicon version of "
+                   "%d.%d when %s option is enabled.\n",
+                   siliconVersion >> 8,
+                   siliconVersion & 0xff,
+                   _PMCD_CMD_ARG_8572_REV_1_0);
+         status = pmc_incompatible_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_0
+      if (pmeVersion != PM_PME_VERSION_2_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.0 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_1
+      if (pmeVersion != PM_PME_VERSION_2_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.1 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+
+      /* Read the expression name length. */
+      readNum = fread(&expNameLength, sizeof(expNameLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      expNameLength = PMP_PMHWTOHL(expNameLength);
+      
+      /* Read the expression name. */
+      if (expNameString_p != NULL)
+      {
+         free(expNameString_p);
+      }
+
+      expNameString_p = calloc(1, expNameLength);
+
+      if (expNameString_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  FAILERROR_S,
+                  strerror(errno));
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      readNum = fread(expNameString_p, expNameLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+  
+      /* Read the expression string length. */
+      readNum = fread(&expStringLength, sizeof(expStringLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      expStringLength = PMP_PMHWTOHL(expStringLength);
+      
+      /* Read the expression string. */
+      if (expString_p != NULL)
+      {
+         free(expString_p);
+      }
+
+      expString_p = calloc(1, expStringLength);
+
+      if (expString_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Failed to allocate %u bytes of memory needed to "
+                  "read the expression string for the \"%s\" expression.\n", 
+                  expStringLength,
+                  expNameString_p);
+         status = pmc_no_memory_e;
+         break;
+      }
+
+      readNum = fread(expString_p, expStringLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+      
+      /* Read the option string length. */
+      readNum = fread(&optionStringLength,
+                      sizeof(optionStringLength),
+                      1, 
+                      binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      optionStringLength = PMP_PMHWTOHL(optionStringLength);
+      
+      /* Read the option string. */
+      if (optionString_p != NULL)
+      {
+         free(optionString_p);
+      }
+
+      optionString_p = calloc(1, optionStringLength);
+
+      if (optionString_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Failed to allocate %u bytes of memory needed to "
+                  "read the option string for the \"%s\" expression.\n", 
+                  optionStringLength,
+                  expNameString_p);
+         status = pmc_no_memory_e;
+         break;
+      }
+
+      readNum = fread(optionString_p, optionStringLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+  
+      /* Read the number of patterns. */
+      readNum = fread(&patternsNum, sizeof(patternsNum), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      patternsNum = PMP_PMHWTOHL(patternsNum);
+  
+      currentPattern_p  = &(exp.patterns);
+      previousPattern_p = NULL;
+  
+      currentPattern_p->nextPatternRecord_p = NULL;
+  
+      /* Read in each pattern */
+      cleanup = 0;
+  
+      for (count = 0; count < patternsNum; count++)
+      {
+         /* The expression record already contains 1 pattern record. If
+          * there is more than one pattern we need to allocate a new
+          * pattern record. */
+         if (count > 0)
+         {
+            currentPattern_p = (pm_pattern_record_t *) calloc(sizeof(pm_pattern_record_t), 1);
+
+            if (currentPattern_p == NULL)
+            {
+               cleanup = 1;
+               status = pmc_no_memory_e;
+               break;
+            }
+            previousPattern_p->nextPatternRecord_p = currentPattern_p;
+         }
+         
+         /* Read the size of the key element entry. */
+         readNum = fread(&keyElementEntrySize,
+                         sizeof(keyElementEntrySize),
+                         1, 
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+
+         keyElementEntrySize = PMP_PMHWTOHL(keyElementEntrySize);
+
+         if (keyElementEntrySize > sizeof(currentPattern_p->keyElementEntry))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read the key element entry for expression "
+                     "with name %s.  The size of the key element entry is %u which "
+                     "is longer than the expected maximum size of %Zd.\n", 
+                     expNameString_p,
+                     keyElementEntrySize, 
+                     sizeof(currentPattern_p->keyElementEntry));
+            cleanup = 1;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+          
+         /* Read the key element entry. */
+         readNum = fread(&(currentPattern_p->keyElementEntry), 
+                         keyElementEntrySize,
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+      
+         /* Read the size of the confirmation entry. */
+         readNum = fread(&confirmationEntrySize,
+                         sizeof(confirmationEntrySize), 
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+
+         confirmationEntrySize = PMP_PMHWTOHL(confirmationEntrySize);
+
+         if (confirmationEntrySize > 
+             sizeof(currentPattern_p->confirmationEntry))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read the confirmation entry for "
+                     "expression with name %s.  The size of the confirmation "
+                     "entry is %u which is longer than the expected maximum "
+                     "size of %Zd.\n",
+                     expNameString_p,
+                     confirmationEntrySize, 
+                     sizeof(currentPattern_p->confirmationEntry));
+            cleanup = 1;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      
+         /* Read the confirmation entry. */
+         readNum = fread(&(currentPattern_p->confirmationEntry), 
+                         confirmationEntrySize,
+                         1,
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status  = pmc_record_read_fail_e;
+            cleanup = 1;
+            break;
+         }
+      
+         /* Check if some of the parameters are not too long for the PMCD
+          * and LL limits. */
+         if (expNameLength > sizeof(exp.name_s))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add an expression record.  Expression name "
+                     "length of %u bytes is larger than the LL maximum supported "
+                     "size of %Zd.\n",
+                     expNameLength,
+                     sizeof(exp.name_s));
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+         else
+         {
+            memcpy(&exp.name_s, expNameString_p, expNameLength);
+
+            if (exp.name_s[expNameLength - 1] != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "Failed to add an expression record.  Found an "
+                        "expression with name that is not NULL terminated.\n");
+               cleanup = 1;
+               status = pmc_record_add_fail_e;
+               break;
+            }
+         }
+
+         if (expStringLength > _PMCD_EXP_STRING_MAX_SIZE)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add an expression record with name "
+                     "\"%s\".  Expression string length of %u bytes is larger "
+                     "than the PMCD maximum supported size of %u.\n",
+                     exp.name_s, 
+                     expStringLength,
+                     _PMCD_EXP_STRING_MAX_SIZE);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (expString_p[expStringLength - 1] != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add an expression record with name "
+                     "\"%s\".  Expression string in this record is not NULL "
+                     "terminated.\n",
+                     exp.name_s);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (optionStringLength > _PMCD_EXP_OPTIONS_STRING_MAX_SIZE)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add an expression record with name "
+                     "\"%s\".  Expression option length of %u bytes is larger "
+                     "than the PMCD maximum supported size of %u.\n",
+                     exp.name_s,
+                     expStringLength,
+                     _PMCD_EXP_OPTIONS_STRING_MAX_SIZE);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+
+         if (optionString_p[optionStringLength - 1] != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add an expression record with name "
+                     "\"%s\".  Options string in this record is not NULL "
+                     "terminated.\n",
+                     exp.name_s);
+            cleanup = 1;
+            status = pmc_record_add_fail_e;
+            break;
+         }
+   
+         previousPattern_p = currentPattern_p;
+      }
+  
+      /* Check if we exited abnormally from reading the patterns */
+      if (cleanup)
+      {
+         /* Free any pattern objects that were created. */
+   
+         while (exp.patterns.nextPatternRecord_p != NULL)
+         {
+            currentPattern_p = exp.patterns.nextPatternRecord_p;
+    
+            exp.patterns.nextPatternRecord_p = (exp.patterns.nextPatternRecord_p)->nextPatternRecord_p;
+    
+            free(currentPattern_p);
+         }
+         break;
+      }
+  
+      /* Attempt to delete the read regex record from the PMLL and PMCD DBs. */
+      ret_val = _pmcd_exp_name_delete(&info_msg_p,
+                                      _pmcd_db_handle_sg,
+                                      expNameString_p);
+
+      if (ret_val == 0)
+      {
+         deletedExpCount++;
+      }
+      else
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Failed to delete regular expression with name "
+                  "\"%s\".  \"%s\"\n",
+                  exp.name_s, 
+                  pmll_error_string_get(pmllStatus));
+         failedExpCount++;
+         status = pmc_record_add_fail_e;
+      }
+  
+      /* Free any pattern objects that were created. */
+      while (exp.patterns.nextPatternRecord_p != NULL)
+      {
+         currentPattern_p = exp.patterns.nextPatternRecord_p;
+   
+         exp.patterns.nextPatternRecord_p = (exp.patterns.nextPatternRecord_p)->nextPatternRecord_p;
+   
+         free(currentPattern_p);
+      }
+   } /* while (true) */
+ 
+   
+   /* Free the expression and option string buffers. */
+   if (expString_p     != NULL) {free(expString_p);}
+   if (optionString_p  != NULL) {free(optionString_p);}
+   if (expNameString_p != NULL) {free(expNameString_p);}
+   
+   if (failedExpCount != 0)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Failed to delete all regexes from the DB.\n");
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successfully deleted all regexes from the DB.\n");
+
+      if (auto_commit)
+      {
+         /* Do the commit */
+         pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit failed with the following error: \"%s\".\n",
+                     pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+
+   fclose(binFile_p);
+ 
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* 
+ * Deletes rules from the specified binary file.
+ */
+static int _pmcd_del_bin_rule_file(uint8_t  *params_p,
+                                   uint8_t **resp_p)
+{
+   char                     *filename_p            = NULL;
+   bool                      auto_commit           = false;
+   char                     *info_msg_p            = NULL;
+   FILE                     *binFile_p             = NULL;
+   uint32_t                  recordType            = 0;
+   uint32_t                  recordVersion         = 0;
+   uint32_t                  pmeVersion            = 0;
+   uint32_t                  siliconVersion        = 0;
+   uint32_t                  ruleNameLength        = 0;
+   size_t                    readNum               = 0;
+   uint32_t                  i                     = 0;
+   uint32_t                  deletedRuleCount      = 0;
+   uint32_t                  failedRuleCount       = 0;
+   bool                      reactionsReadOk       = false;
+   bool                      tryToAddRule          = false;
+   pmll_status_t             pmllStatus            = pmll_ok_e;
+   char                     *ruleNameString_p      = NULL;
+   pm_rule_record_v_1_0_0_t *rule_p                = NULL;
+   int                       status                = 0;
+   int                       ret_val               = 0;
+    
+   /* 2 parameters:
+    *    - string -> file name
+    *    - bool   -> auto commit flag
+    */
+
+   MSG_EXTRACT_STR (params_p, filename_p);
+   MSG_EXTRACT_BOOL(params_p, auto_commit);
+
+   /* Prepare response */
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_INIT(*resp_p, _pmc_del_bin_rule_file_response_e);
+
+   /* Try to open the binary file to read the records from. */
+   binFile_p = fopen(filename_p, "r");
+
+   if (binFile_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Could not open file ->%s<-.  %s\n", 
+                filename_p,
+                strerror(errno));
+
+      MSG_ADD_UINT32_FIELD(*resp_p, pmc_open_file_fail_e);
+      MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+      free(info_msg_p);
+      return 0;
+   }
+
+   /* Read the rule records from the file. */
+   while (true)
+   {
+      /* Allocate a rule record.  This record will be filled with the
+       * data read from the binary rule record, then added to the PMLL
+       * DB and then freed.  It is not optimal but it is simple. */
+      rule_p = (pm_rule_record_v_1_0_0_t *)calloc(1, sizeof(pm_rule_record_v_1_0_0_t));
+
+      if (rule_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  FAILERROR_S,
+                  strerror(errno));
+         status = pmc_no_memory_e;
+         break;
+      }
+      
+   
+      /* Read the record type. */
+      readNum = fread(&recordType, sizeof(recordType), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (0 == feof(binFile_p))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            status = pmc_record_read_fail_e;
+         }
+         break;
+      }
+      else
+      {
+         /* Make sure this is a rule record. */
+         if (PMP_PMHWTOHL(recordType) != PM_COMPILED_RULE_RECORD_TYPE)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read a record from a binary file.  The "
+                     "record has an unexpected record type of %#x.\n", 
+                     PMP_PMHWTOHL(recordType));
+            status = pmc_record_read_fail_e;
+            break;
+         }
+      }
+      
+      /* Read the rule record version. */
+      readNum = fread(&recordVersion, sizeof(recordVersion), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      recordVersion = PMP_PMHWTOHL(recordVersion);
+      /* Check if the read rule record version is as we expect it to be,
+       * i.e., PM_RULE_BIN_RECORD_V_1_0_0. */
+      /* Check if the read rule record version is as we expect it to
+       * be. Currently these version are supported: 
+       * PM_RULE_BIN_RECORD_V_1_0_0
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_1_1 + PM_SI_VERSION_1_0 
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_0 + PM_SI_VERSION_1_0
+       * PM_RULE_BIN_RECORD_V_2_0_0 + PM_PME_VERSION_2_1 + PM_SI_VERSION_1_0 */
+  
+      if (recordVersion != PM_RULE_BIN_RECORD_V_1_0_0 && 
+          recordVersion != PM_RULE_BIN_RECORD_V_2_0_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported binary rule record version of %#x.\n",
+                  recordVersion);
+        status = pmc_record_read_fail_e;
+        break;
+      }
+
+      if (recordVersion == PM_RULE_BIN_RECORD_V_2_0_0)
+      {
+         /* With PM_RULE_BIN_RECORD_V_2_0_0, two more fields pmeVersion and 
+          * siliconVersion are being read here. */
+         readNum = fread(&pmeVersion, sizeof(pmeVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         pmeVersion = PMP_PMHWTOHL(pmeVersion);
+
+         readNum = fread(&siliconVersion, sizeof(siliconVersion), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         siliconVersion = PMP_PMHWTOHL(siliconVersion);
+      }
+      else
+      {
+         /* PM_RULE_BIN_RECORD_V_1_0_0 - only for PME 1.1, Si 1.0. */
+         pmeVersion     = PM_PME_VERSION_1_1;
+         siliconVersion = PM_SI_VERSION_1_0;
+      }
+      
+#ifdef PME_1_1
+      if (pmeVersion != PM_PME_VERSION_1_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 1.1 silicon version 1.0 is supported. */
+      if (PM_SI_VERSION_1_0 != siliconVersion)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_0
+      if (pmeVersion != PM_PME_VERSION_2_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+      /* Only PME 2.0 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+#ifdef PME_2_1
+      if (pmeVersion != PM_PME_VERSION_2_1)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported PME version of %d.%d\n",
+                  pmeVersion >> 8,
+                  pmeVersion & 0xff);
+         status = pmc_unsupported_pme_ver_e;
+         break;
+      }
+
+      /* Only PME 2.1 silicon version 1.0 is supported. */
+      if (siliconVersion != PM_SI_VERSION_1_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found unsupported silicon version of %d.%d\n",
+                  siliconVersion >> 8,
+                  siliconVersion & 0xff);
+         status = pmc_unsupported_si_ver_e;
+         break;
+      }
+#endif
+  
+      /* Read the rule name length. */
+      readNum = fread(&ruleNameLength, sizeof(ruleNameLength), 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      ruleNameLength = PMP_PMHWTOHL(ruleNameLength);
+  
+      /* Read the rule name.  We read the entire name of the rule to be
+       * able to display it in case it is too long. */
+      if (ruleNameString_p != NULL)
+      {
+         free(ruleNameString_p);
+      }
+
+      ruleNameString_p = (char *)calloc(1, ruleNameLength);
+
+      if (ruleNameString_p == NULL)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  FAILERROR_S,
+                  strerror(errno));
+        status = pmc_no_memory_e;
+        break;
+      }
+
+      readNum = fread(ruleNameString_p, ruleNameLength, 1, binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      /* Check if the length of the rule name is not too long. */
+      if (ruleNameString_p[ruleNameLength - 1] != 0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Found a rule with name that is not NULL terminated.\n");
+         status = pmc_record_add_fail_e;
+         tryToAddRule = false;
+      }
+
+      if (ruleNameLength > sizeof(rule_p->name_s))
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Failed to add a rule record with rule name \"%s\".  "
+                  "Rule name length of %u bytes is larger than the LL maximum "
+                  "supported size of %Zd.\n",
+                  ruleNameString_p,
+                  ruleNameLength,
+                  sizeof(rule_p->name_s));
+         status = pmc_record_add_fail_e;
+         tryToAddRule = false;
+      }
+      else
+      {
+         /* Copy the read rule name into the PMLL rule record. */
+         strncpy(rule_p->name_s, ruleNameString_p, ruleNameLength);
+
+         if (rule_p->name_s[PM_NAME_MAX_LENGTH - 1] != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Found a rule with name that is not NULL "
+                     "terminated after being copied.\n");
+            status = pmc_record_add_fail_e;
+            tryToAddRule = false;
+         }
+      }
+      
+      /* Read the number of the reactions present in this rule. */
+      readNum = fread(&rule_p->reactionNum,
+                      sizeof(rule_p->reactionNum),
+                      1, 
+                      binFile_p);
+
+      if (readNum != 1)
+      {
+         if (feof(binFile_p) != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     EOFERROR_S);
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+         }
+         status = pmc_record_read_fail_e;
+         break;
+      }
+
+      rule_p->reactionNum = PMP_PMHWTOHL(rule_p->reactionNum);
+  
+      /* Now read all the reactions in this rule.  Also link these
+       * reactions together as required by the PMLL rule record. */
+      pm_reaction_entry_t **pointToThisReaction_p = &rule_p->reactionEntry_p;
+      uint32_t              eventType             = 0;
+      uint32_t              expNameLength         = 0;
+      char                 *expNameString_p       = NULL;
+      uint8_t              *reactionData_p        = NULL;
+      reactionsReadOk                             = true;
+      tryToAddRule                                = true;
+     
+      for (i = 0; i < rule_p->reactionNum; i++)
+      {
+         /* Allocate memory for this reaction. */
+         pm_reaction_entry_t *reaction_p = calloc(1, sizeof(pm_reaction_entry_t));
+
+         if (reaction_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_no_memory_e;
+            break;
+         }
+         else
+         {
+            *pointToThisReaction_p = reaction_p;
+         }
+       
+         /* Read the event type */
+         readNum = fread(&eventType, sizeof(eventType), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         reaction_p->reactionEventType = PMP_PMHWTOHL(eventType);
+   
+         /* Read the length of the expression name. */
+         readNum = fread(&expNameLength, sizeof(expNameLength), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         expNameLength = PMP_PMHWTOHL(expNameLength);
+
+         /* Read the name of the expression. */
+         if (expNameString_p != NULL)
+         {
+            free(expNameString_p);
+         }
+
+         expNameString_p = calloc(1, expNameLength);
+
+         if (expNameString_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_no_memory_e;
+            break;
+         }
+
+         readNum = fread(expNameString_p, expNameLength, 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+   
+         /* Check if the expression name is NULL terminated. */
+         if (expNameString_p[expNameLength - 1] != 0)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Reaction %u in rule \"%s\" has expression name "
+                     "that is not NULL terminated.\n",
+                     i + 1,
+                     rule_p->name_s);
+            status = pmc_record_read_fail_e;
+            tryToAddRule = false;
+         }
+
+         /* Check if the length of the expression name is not too long. */
+         if (expNameLength > sizeof(reaction_p->expName_s))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to add a rule record with rule name \"%s\".  "
+                     "A reaction refers to expression \"%s\" with name length "
+                     "of %u which is too big.  The maximum expression name "
+                     "length supported by LL is %Zd.\n",
+                     rule_p->name_s, 
+                     expNameString_p,
+                     expNameLength, 
+                     sizeof(reaction_p->expName_s));
+            status = pmc_record_read_fail_e;
+            tryToAddRule = false;
+         }
+         else
+         {
+            /* Copy the read expression name into the PMLL reaction record. */
+            strncpy(reaction_p->expName_s, expNameString_p, expNameLength);
+
+            if (reaction_p->expName_s[PM_NAME_MAX_LENGTH - 1] != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        "Reaction %u in rule \"%s\" has expression name "
+                        "that is not NULL terminated after being copied.\n", 
+                        i + 1,
+                        rule_p->name_s);
+               status       = pmc_record_read_fail_e;
+               tryToAddRule = false;
+            }
+         }
+         
+         /* Read the size of the reaction. */
+         readNum = fread(&reaction_p->reactionSize, 
+                         sizeof(reaction_p->reactionSize), 1, binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         reaction_p->reactionSize = PMP_PMHWTOHL(reaction_p->reactionSize);
+         
+         /* Read the reaction. */
+         if (reactionData_p != NULL)
+         {
+            free(reactionData_p);
+         }
+
+         reactionData_p = calloc(1, reaction_p->reactionSize);
+
+         if (reactionData_p == NULL)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     FAILERROR_S,
+                     strerror(errno));
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         readNum = fread(reactionData_p, reaction_p->reactionSize, 1, 
+                         binFile_p);
+
+         if (readNum != 1)
+         {
+            if (feof(binFile_p) != 0)
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        EOFERROR_S);
+            }
+            else
+            {
+               snprintf(info_msg_p,
+                        _PMC_MAX_ERROR_MSG_SIZE,
+                        FAILERROR_S,
+                        strerror(errno));
+            }
+            reactionsReadOk = false;
+            status = pmc_record_read_fail_e;
+            break;
+         }
+
+         if (reaction_p->reactionSize > sizeof(reaction_p->reactionData))
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to read a rule record.  Size of "
+                     "reaction for rule \"%s\" and expression \"%s\" of %u "
+                     "bytes is too big.  The maximum reaction size supported "
+                     "by LL is %Zd.\n",
+                     rule_p->name_s,
+                     reaction_p->expName_s, 
+                     reaction_p->reactionSize,
+                     sizeof(reaction_p->reactionData));
+            status       = EINVAL;
+            tryToAddRule = false;
+         }
+         else
+         {
+            /* Copy the read reaction data into the PMLL reaction record. */
+            memcpy(reaction_p->reactionData,
+                   reactionData_p, 
+                   reaction_p->reactionSize);
+         }
+   
+         /* Adjust the pointToThisReaction_p pointer. */
+         pointToThisReaction_p = &reaction_p->nextReactionEntry_p;
+      } /* for - read the expressions in the rule */
+  
+  
+      /* The rule has been read.  If the rule has been read successfully
+       * then the rule record has been created and is ready to be added
+       * to LL. */
+      if (reactionsReadOk == false)
+      {
+         /* We failed to read the rule.  We must bail out from reading
+          * the file. */
+         failedRuleCount++;
+         break;
+      }
+      
+      /* We read the rule successfully.  Check if we can add it to LL. */
+      if (tryToAddRule == true)
+      {
+         ret_val = _pmcd_rule_name_delete(_pmcd_db_handle_sg,
+                                          expNameString_p);
+  
+         if (ret_val == 0)
+         {
+            deletedRuleCount++;
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "Failed to delete rule with name "
+                     "\"%s\".  \"%s\"\n",
+                     expNameString_p, 
+                     pmll_error_string_get(pmllStatus));
+            failedRuleCount++;
+            status = pmc_record_add_fail_e;
+
+         }
+      }
+      else
+      {
+         /* We read the rule successfuly but the data read contained errors. */
+         failedRuleCount++;
+      }
+  
+      /* We are done with this rule.  Free all the allocated memory
+       * blocks used to add this rule.  If needed again they will be
+       * reallocated. */
+      if (rule_p != NULL)
+      { 
+         _pmcd_pm_rule_free(rule_p);
+         rule_p = NULL; 
+      }
+
+      if (ruleNameString_p != NULL)
+      { 
+         free(ruleNameString_p); 
+         ruleNameString_p = NULL; 
+      }
+
+      if (expNameString_p != NULL)
+      { 
+         free(expNameString_p); 
+         expNameString_p = NULL; 
+      }
+
+      if (reactionData_p != NULL)
+      {
+         free(reactionData_p); 
+         reactionData_p = NULL; 
+      }
+  
+      /* Check if we are not spinning in the while(true) loop. */
+      if (deletedRuleCount > PM_STATEFUL_RULE_MAX_NUM_V2_0)
+      {
+         snprintf(info_msg_p,
+                  _PMC_MAX_ERROR_MSG_SIZE,
+                  "Bad logic in function or there are too many rules in "
+                  "the binary file.;  spinning in a while loop "
+                  "(deletedRuleCount=%u, failedRuleCount=%u).", 
+                  deletedRuleCount,
+                  failedRuleCount);
+        status = pmc_record_add_fail_e;
+        break;
+      }
+   } /* while - read all the rules from the binary file. */
+ 
+ 
+   /* We are done with the file.  Free all the allocated memory blocks. */
+   if (rule_p != NULL)
+   { 
+      free(rule_p); 
+      rule_p = NULL; 
+   }
+
+   if (ruleNameString_p != NULL)
+   { 
+      free(ruleNameString_p); 
+      rule_p = NULL; 
+   }
+ 
+   if (failedRuleCount != 0)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Failed to remove all rules from the DB.\n");
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successfully removed all rules from the DB.\n");
+
+      if (auto_commit)
+      {
+         _pmcd_db_t *pmcdDb_p = _pmcd_db_handle_sg;
+         /* Do the commit */
+         pmllStatus = pmll_commit(pmcdDb_p->llDbHandle, "");
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit failed with the following error: \"%s\".\n",
+                     pmll_error_string_get(pmllStatus));
+   
+            status = pmc_commit_fail_e;
+         }
+         else
+         {
+            snprintf(info_msg_p,
+                     _PMC_MAX_ERROR_MSG_SIZE,
+                     "The commit was successful.\n");
+      
+            status = pmc_ok_e;
+         }
+      }
+   }
+   
+   fclose(binFile_p);
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+} /* _pmcd_rules_from_bin_file_add */
+
+/* -------------------------------------------------------------------------- *
+ * Query an expression with a given name.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_expr_name(uint8_t  *params_p,
+                                 uint8_t **resp_p)
+{
+   pmc_status_t        status      = pmc_ok_e;
+   char               *info_msg_p  = NULL;
+   char               *name_p      = NULL;
+   _pmcd_db_t         *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_exp_record_t *exp_p       = NULL;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_STR (params_p, name_p);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_expr_name_response_e);
+
+   /* Do the query */
+   exp_p = db_record_by_name_get(pmcdDb_p->expDbHandle, name_p); 
+
+   if (exp_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No expression with name ->%s<- exists in DB.\n",
+               name_p);
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->exp_s);
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->options_s);
+      MSG_ADD_UINT32_FIELD(*resp_p, exp_p->pmcdIndex);
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query expressions with a given set/subset.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_expr_set(uint8_t  *params_p,
+                                uint8_t **resp_p)
+{
+   pmc_status_t        status      = pmc_ok_e;
+   char               *info_msg_p  = NULL;
+   uint8_t             set         = 0;
+   uint16_t            subset      = 0xffff;
+   _pmcd_db_t         *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_exp_record_t *exp_p       = NULL;
+   uint32_t            num_exprs   = 0;
+   uint32_t            count       = 0;
+   dll_list_t         *set_list_p  = NULL;
+   uint32_t            list_size   = 0;
+   dll_node_t         *node_p      = NULL;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_UINT8 (params_p, set);
+   MSG_EXTRACT_UINT16(params_p, subset);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_expr_set_response_e);
+
+   set_list_p = &(pmcdDb_p->set[set]);
+
+   list_size = (uint32_t)dll_count(set_list_p);
+
+   /* Go through the list for the appropriate set and make sure the subset
+    * matches. 
+    */
+   node_p = dll_get_first(set_list_p);
+
+   while (node_p != NULL)
+   {
+      exp_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                       _pmcd_exp_record_t,
+                                       dll_node);
+
+      if ((exp_p->subset & subset) > 0)
+      {
+         num_exprs++;
+      }
+
+      node_p = dll_get_next_node(set_list_p, node_p);
+   }
+
+   if (num_exprs == 0)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No expressions with set %d and subset %d exist in DB.\n",
+               set,
+               subset);
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_UINT32_FIELD(*resp_p, num_exprs);
+
+      for (count = 0; count < num_exprs; count++)
+      {
+         node_p = dll_get_first(set_list_p);
+      
+         while (node_p != NULL)
+         {
+            exp_p = DLL_STRUCT_FROM_NODE_GET(node_p,
+                                             _pmcd_exp_record_t,
+                                             dll_node);
+      
+            if ((exp_p->subset & subset) > 0)
+            {
+               MSG_ADD_STR_FIELD   (*resp_p, exp_p->name_s);
+               MSG_ADD_STR_FIELD   (*resp_p, exp_p->exp_s);
+               MSG_ADD_STR_FIELD   (*resp_p, exp_p->options_s);
+               MSG_ADD_UINT32_FIELD(*resp_p, exp_p->pmcdIndex);
+            }
+      
+            node_p = dll_get_next_node(set_list_p, node_p);
+         }
+      }
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query the first expression in the DB.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_expr_first(uint8_t  *params_p,
+                                  uint8_t **resp_p)
+{
+   pmc_status_t        status      = pmc_ok_e;
+   char               *info_msg_p  = NULL;
+   _pmcd_db_t         *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_exp_record_t *exp_p       = NULL;
+   uint32_t            exp_index   = IDX_NULL_INDEX;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   /* No parameters for this query. Get rid of warning. */
+   params_p = params_p;
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_expr_first_response_e);
+
+   /* Do the query */
+
+   exp_p = db_record_next_get(pmcdDb_p->expDbHandle, &exp_index); 
+
+   if (exp_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No expressions exist in DB.\n");
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->name_s);
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->exp_s);
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->options_s);
+      MSG_ADD_UINT32_FIELD(*resp_p, exp_p->pmcdIndex);
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query the next expression in the DB.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_expr_next(uint8_t  *params_p,
+                                 uint8_t **resp_p)
+{
+   pmc_status_t        status      = pmc_ok_e;
+   char               *info_msg_p  = NULL;
+   _pmcd_db_t         *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_exp_record_t *exp_p       = NULL;
+   uint32_t            exp_index   = IDX_NULL_INDEX;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_UINT32(params_p, exp_index);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_expr_next_response_e);
+
+   /* Do the query */
+
+   exp_p = db_record_next_get(pmcdDb_p->expDbHandle, &exp_index); 
+
+   if (exp_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No next expression found in DB.\n");
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->name_s);
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->exp_s);
+      MSG_ADD_STR_FIELD   (*resp_p, exp_p->options_s);
+      MSG_ADD_UINT32_FIELD(*resp_p, exp_p->pmcdIndex);
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query a rule with a given name.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_rule_name(uint8_t  *params_p,
+                                 uint8_t **resp_p)
+{
+   pmc_status_t         status      = pmc_ok_e;
+   char                *info_msg_p  = NULL;
+   char                *name_p      = NULL;
+   _pmcd_db_t          *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_rule_record_t *rule_p      = NULL;
+   int                  count       = 0;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_STR (params_p, name_p);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_rule_name_response_e);
+
+   /* Do the query */
+   rule_p = db_record_by_name_get(pmcdDb_p->ruleDbHandle, name_p); 
+
+   if (rule_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No rule with name ->%s<- exists in DB.\n",
+               name_p);
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_UINT32_FIELD(*resp_p, rule_p->reactionNum);
+
+      for (count = 0; count < (int)rule_p->reactionNum; count++)
+      {
+         MSG_ADD_STR_FIELD(*resp_p, (rule_p->reactionNames_p)[count]);
+      }
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query the first rule in the DB.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_rule_first(uint8_t  *params_p,
+                                  uint8_t **resp_p)
+{
+   pmc_status_t         status      = pmc_ok_e;
+   char                *info_msg_p  = NULL;
+   _pmcd_db_t          *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_rule_record_t *rule_p      = NULL;
+   int                  count       = 0;
+   uint32_t             rule_index  = IDX_NULL_INDEX;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   /* No params for this query. Get rid of warning. */
+   params_p = params_p;
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_rule_first_response_e);
+
+   /* Do the query */
+   rule_p = db_record_next_get(pmcdDb_p->ruleDbHandle, &rule_index); 
+
+   if (rule_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No rules exists in DB.\n");
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD   (*resp_p, rule_p->name_s);
+      MSG_ADD_UINT32_FIELD(*resp_p, rule_p->reactionNum);
+
+      for (count = 0; count < (int)rule_p->reactionNum; count++)
+      {
+         MSG_ADD_STR_FIELD(*resp_p, (rule_p->reactionNames_p)[count]);
+      }
+      MSG_ADD_UINT32_FIELD(*resp_p, rule_index);
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Query the next rule in the DB.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_query_rule_next(uint8_t  *params_p,
+                                 uint8_t **resp_p)
+{
+   pmc_status_t         status      = pmc_ok_e;
+   char                *info_msg_p  = NULL;
+   _pmcd_db_t          *pmcdDb_p    = _pmcd_db_handle_sg;
+   _pmcd_rule_record_t *rule_p      = NULL;
+   int                  count       = 0;
+   uint32_t             rule_index  = IDX_NULL_INDEX;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_UINT32(params_p, rule_index);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_query_rule_next_response_e);
+
+   /* Do the query */
+   rule_p = db_record_next_get(pmcdDb_p->ruleDbHandle, &rule_index); 
+
+   if (rule_p == NULL)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "No next rule exists in DB.\n");
+      status = pmc_query_fail_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Successful query.\n");
+      status = pmc_ok_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   if (status == pmc_ok_e)
+   {
+      MSG_ADD_STR_FIELD   (*resp_p, rule_p->name_s);
+      MSG_ADD_UINT32_FIELD(*resp_p, rule_p->reactionNum);
+
+      for (count = 0; count < (int)rule_p->reactionNum; count++)
+      {
+         MSG_ADD_STR_FIELD(*resp_p, (rule_p->reactionNames_p)[count]);
+      }
+      MSG_ADD_UINT32_FIELD(*resp_p, rule_index);
+   }
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Set the variable length trigger.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_set_var_trig(uint8_t  *params_p,
+                              uint8_t **resp_p)
+{
+   pmc_status_t    status      = pmc_ok_e;
+   char           *info_msg_p  = NULL;
+   _pmcd_db_t     *pmcdDb_p    = _pmcd_db_handle_sg;
+   uint32_t        trig_size   = 1;
+   pmll_status_t   pmllStatus  = pmll_ok_e;
+
+   info_msg_p = (char *)calloc(_PMC_MAX_ERROR_MSG_SIZE, 1);
+
+   if (info_msg_p == NULL)
+   {
+      LOG_PRINT("%s:%d No memory available to allocate info_msg_p\n",
+                 __FILE__, __LINE__);
+      return ENOMEM;
+   }
+
+   MSG_EXTRACT_UINT32(params_p, trig_size);
+
+   /* Prepare response */
+   MSG_INIT(*resp_p, _pmc_set_var_trig_response_e);
+
+   /* Do the set */
+   pmllStatus = pmll_variable_trigger_size_set(pmcdDb_p->llDbHandle, 
+                                               trig_size);
+
+
+   if (pmllStatus == pmll_ok_e)
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Trigger size successfully set.\n");
+      status = pmc_ok_e;
+   }
+   else
+   {
+      snprintf(info_msg_p,
+               _PMC_MAX_ERROR_MSG_SIZE,
+               "Failed to set trigger size.\n");
+      status = pmc_set_var_trig_fail_e;
+   }
+
+   MSG_ADD_UINT32_FIELD(*resp_p, status);
+   MSG_ADD_STR_FIELD   (*resp_p, info_msg_p);
+
+   free(info_msg_p);
+   return 0;
+}
+
+/* Destroy the indicated PMCD database.
+ *
+ * param pmcdDbHandle  Handle of the PMCD DB to destroy.
+ * retval              true upon success; false otherwise.
+ */
+static bool _pmcd_db_destroy(handle_t pmcdDbHandle)
+{
+   PmlaError_t    pmlaStatus   = pmlaSuccess_c;
+   pmll_status_t  pmllStatus   = pmll_ok_e;
+   db_status_t    dbStatus     = db_ok_e;
+   bool           returnStatus = true;
+   _pmcd_db_t    *pmcdDb_p     = pmcdDbHandle;
+   char          *info_msg_p   = NULL;
+  
+   if (pmcdDb_p == HANDLE_NULL)
+   {
+      return true;
+   }
+ 
+   /* Shut down the PMLA communication channel used by PMLL. */
+   if (pmcdDb_p->pmlaForPmllHandle != HANDLE_NULL)
+   {
+      pmlaStatus = pmlaClose(pmcdDb_p->pmlaForPmllHandle);
+
+      if (pmlaStatus != pmlaSuccess_c)
+      {
+         LOG_PRINT("Failed to destroy the PMLA connection used by PMLL. %s\n",
+                   pmlaErrorString(pmlaStatus));
+         returnStatus = false;
+      }
+   }
+ 
+   /* Shut down the PMLA communication channel used by PMCD. */
+   if (pmcdDb_p->pmlaForPmcdHandle != HANDLE_NULL)
+   {
+      pmlaStatus = pmlaClose(pmcdDb_p->pmlaForPmcdHandle);
+
+      if (pmlaStatus != pmlaSuccess_c)
+      {
+         LOG_PRINT("Failed to destroy the PMLA connection used by PMCD. %s\n",
+                   pmlaErrorString(pmlaStatus));
+         returnStatus = false;
+      }
+   }
+  
+   /* Delete all the expressions and rules in the PMCD expression and
+    * rule DBs. */
+   LOG_PRINT("Deleting all the rule records.\n");
+   _pmcd_rule_all_delete(pmcdDbHandle);
+
+   LOG_PRINT("Deleting all the expression records.\n");
+   _pmcd_exp_all_delete(&info_msg_p,
+                        pmcdDbHandle);
+ 
+   /* Destroy the PMLL DB. */
+   if (pmcdDb_p->llDbHandle != _PMCD_NULL_PMLL_DB_HANDLE)
+   {
+      LOG_PRINT("Destroying the PMLL DB.\n");
+
+      pmllStatus = pmll_db_destroy(pmcdDb_p->llDbHandle);
+
+      if (pmllStatus != pmll_ok_e)
+      {
+         LOG_PRINT("Failed to destroy the PMLL DB. %s\n",
+                   pmll_error_string_get(pmllStatus));
+         returnStatus = false;
+      }
+   }
+ 
+   /* Destroy the PMCD rule and expression DBs. */
+   LOG_PRINT("Destroying the PMCD rule DB.\n");
+   dbStatus = db_db_destroy(pmcdDb_p->ruleDbHandle);
+
+   if (dbStatus != db_ok_e)
+   {
+      LOG_PRINT("Failed to destroy the PMCD rule DB. %s\n",
+                db_error_string_get(dbStatus));
+      returnStatus = false;
+   }
+
+   LOG_PRINT("Destroying the PMCD expression DB.\n");
+   dbStatus = db_db_destroy(pmcdDb_p->expDbHandle);
+
+   if (dbStatus != db_ok_e)
+   {
+      LOG_PRINT("Failed to destroy the PMCD expression DB. %s\n",
+                db_error_string_get(dbStatus));
+      returnStatus = false;
+   }
+   
+   /* Free the PMCD DB record. */
+   free(pmcdDb_p);
+   
+   return true;
+} /* _pmcd_db_destroy */
+
+/* -------------------------------------------------------------------------- *
+ * Register all command functions
+ * -------------------------------------------------------------------------- */
+static int _pmcd_register_command_functions(_pmcd_command_t **command_table_p)
+{
+   _pmcd_command_t *cmd_p;
+
+//   REGISTER_CMD(_pmc_ping_e,              &ping_cmd);
+//   REGISTER_CMD(_pmc_dummy_e,             &dummy_cmd);
+   REGISTER_CMD(_pmc_add_bin_expr_file_e, &_pmcd_add_bin_expr_file);
+   REGISTER_CMD(_pmc_add_bin_rule_file_e, &_pmcd_add_bin_rule_file);
+   REGISTER_CMD(_pmc_del_all_expr_e,      &_pmcd_del_all_expr);
+   REGISTER_CMD(_pmc_del_all_rule_e,      &_pmcd_del_all_rule);
+   REGISTER_CMD(_pmc_del_all_e,           &_pmcd_del_all);
+   REGISTER_CMD(_pmc_del_expr_name_e,     &_pmcd_del_expr_name);
+   REGISTER_CMD(_pmc_del_expr_set_e,      &_pmcd_del_expr_set);
+   REGISTER_CMD(_pmc_del_rule_name_e,     &_pmcd_del_rule_name);
+   REGISTER_CMD(_pmc_del_bin_expr_file_e, &_pmcd_del_bin_expr_file);
+   REGISTER_CMD(_pmc_del_bin_rule_file_e, &_pmcd_del_bin_rule_file);
+   REGISTER_CMD(_pmc_commit_e,            &_pmcd_commit);
+   REGISTER_CMD(_pmc_query_expr_name_e,   &_pmcd_query_expr_name);
+   REGISTER_CMD(_pmc_query_expr_set_e,    &_pmcd_query_expr_set);
+   REGISTER_CMD(_pmc_query_expr_first_e,  &_pmcd_query_expr_first);
+   REGISTER_CMD(_pmc_query_expr_next_e,   &_pmcd_query_expr_next);
+   REGISTER_CMD(_pmc_query_rule_name_e,   &_pmcd_query_rule_name);
+   REGISTER_CMD(_pmc_query_rule_first_e,  &_pmcd_query_rule_first);
+   REGISTER_CMD(_pmc_query_rule_next_e,   &_pmcd_query_rule_next);
+   REGISTER_CMD(_pmc_set_var_trig_e,      &_pmcd_set_var_trig);
+   REGISTER_CMD(_pmc_analysis_e,          &_pmcd_analysis);
+   REGISTER_CMD(_pmc_stats_e,             &_pmcd_stats);
+   REGISTER_CMD(_pmc_stats_reset_e,       &_pmcd_stats_reset);
+   return 0;
+}
+
+/* 
+ * Retrieve platform specific parameters from the PM H/W.
+ *
+ * This function attempts to read all the platform specific parameters
+ * from the PM H/W identified by the pmlaHandle channel that are
+ * needed to create a PMLL DB.
+ *
+ * At present the function reads the following parameters:
+ * dxeSreTableSize       Location of where to store the read number of
+ *                       the DXE and SRE confirmation entries. 
+ * sreSessionCtxSize     Location of where to store the read size of
+ *                       the SRE session context. 
+ * sreSessionCtxNum      Location of where to store the read number of
+ *                       the sessions. 
+ * sreRuleNum            Location of where to store the read maximum
+ *                       number of the stateful rules. 
+ *
+ * param pmlaHandle      Handle of the PMLA connection to use.
+ * param pmllDbParams_p  Where to store the read PMLL DB parameters.
+ * retval                true on success; false otherwise.  When true
+ *                       is returned the values of the read parameters
+ *                       are passed back through the pointer parameters.
+ */
+static PmlaError_t _pmcd_target_params_get(handle_t          pmlaHandle,
+                                           pmll_db_params_t *pmllDbParams_p)
+{
+   bool                              boolStatus        = false;
+   uint32_t                          attributeSize     = 0;
+   pmp_extension_block_num_attr_t    dxeSreTableSize   = 0;
+   pmp_context_area_size_attr_t      sreSessionCtxSize = 0;
+   pmp_context_max_num_attr_t        sreSessionCtxNum  = 0;
+   pmp_max_stateful_rule_num_attr_t  sreRuleNum        = 0;
+   pmp_hw_revision_t                 hwRevision;
+   
+   /* Read the number of the confirmation entries. */
+   boolStatus = _pmcd_attribute_read(pmlaHandle, 
+                                     pmp_extension_block_num_attr_id_e,
+                                     &dxeSreTableSize,
+                                     &attributeSize);
+   if (boolStatus != true)
+   {
+      LOG_PRINT("An attempt to read the number of the available "
+                "confirmation entries attribute failed.\n");
+      return false;
+   }
+   else if (sizeof(pmp_extension_block_num_attr_t) != attributeSize)
+   {
+      LOG_PRINT("The read extension block number attribute has an "
+                "unexpected size.  Expected size is %Zd; read size is %u.\n",
+                sizeof(pmp_extension_block_num_attr_t),
+                attributeSize);
+      return false;
+   }
+ 
+   /* Read the session context size. */
+   boolStatus = _pmcd_attribute_read(pmlaHandle, 
+                                     pmp_context_area_size_attr_id_e,
+                                     &sreSessionCtxSize,
+                                     &attributeSize);
+   if (boolStatus != true)
+   {
+      LOG_PRINT("An attempt to read the session context size attribute failed.\n");
+      return false;
+   }
+   else if (sizeof(pmp_context_area_size_attr_t) != attributeSize)
+   {
+      LOG_PRINT("The read context area size attribute has an unexpected "
+                "size.  Expected size is %Zd; read size is %u.\n", 
+                sizeof(pmp_context_area_size_attr_t),
+                attributeSize);
+     return false;
+   } 
+ 
+   /* Read the session number. */
+   boolStatus = _pmcd_attribute_read(pmlaHandle,
+                                     pmp_context_max_num_attr_id_e,
+                                     &sreSessionCtxNum,
+                                     &attributeSize);
+   if (boolStatus != true)
+   {
+      LOG_PRINT("An attempt to read the session context size attribute failed.\n");
+      return false;
+   }
+   else if (sizeof(pmp_context_max_num_attr_t) != attributeSize)
+   {
+      LOG_PRINT("The read session context size attribute has an "
+                "unexpected size.  Expected size is %Zd; read size is %u.\n", 
+                sizeof(pmp_context_max_num_attr_t),
+                attributeSize);
+      return false;
+   } 
+ 
+ 
+   /* Read the maximum number of the stateful rules. */
+   boolStatus = _pmcd_attribute_read(pmlaHandle, 
+                                     pmp_max_stateful_rule_num_attr_id_e,
+                                     &sreRuleNum,
+                                     &attributeSize);
+   if (boolStatus != true)
+   {
+      LOG_PRINT("An attempt to read the maximum number of stateful "
+                "rules attribute failed.\n");
+      return false;
+   }
+   else if (sizeof(pmp_max_stateful_rule_num_attr_t) != attributeSize)
+   {
+      LOG_PRINT("The read maximum number of the stateful rules attribute "
+                "has an unexpected size.  Expected size is %Zd; read size is "
+                "%u.\n",
+                sizeof(pmp_max_stateful_rule_num_attr_t),
+                attributeSize);
+      return false;
+   }
+   
+   /* Read the HW revision. */
+   boolStatus = _pmcd_attribute_read(pmlaHandle, 
+                                     pmp_hardware_revision_attr_id_e,
+                                     &hwRevision,
+                                     &attributeSize);
+   if (boolStatus != true)
+   {
+      LOG_PRINT("An attempt to read HW revision attribute failed.\n");
+      return false;
+   }
+   else if (sizeof(pmp_hw_revision_t) != attributeSize)
+   {
+      LOG_PRINT("The read maximum number of the HW revision attribute "
+                "has an unexpected size.  Expected size is %Zd; read size is "
+                "%u.\n",
+                sizeof(pmp_hw_revision_t),
+                attributeSize);
+      return false;
+   }
+ 
+   if (hwRevision.coreMajor == PM_HW_REVISION_V1_1_MAJOR &&
+       hwRevision.coreMinor == PM_HW_REVISION_V1_1_MINOR)
+   {
+      pmllDbParams_p->hwRevision = PM_PME_VERSION_1_1;
+   }
+   else if (hwRevision.coreMajor == PM_HW_REVISION_V2_0_MAJOR &&
+            hwRevision.coreMinor == PM_HW_REVISION_V2_0_MINOR)
+   {
+      pmllDbParams_p->hwRevision = PM_PME_VERSION_2_0;
+   }
+   else
+   {
+      LOG_PRINT("Unsupported HW revision: Major=0x%02x, Minor=0x%02x\n", 
+                hwRevision.coreMajor,
+                hwRevision.coreMinor);
+      return false;
+   }
+   
+   pmllDbParams_p->dxeSreTableSize   = PMP_PMHWTOHL(dxeSreTableSize);
+   pmllDbParams_p->sreSessionCtxSize = PMP_PMHWTOHL(sreSessionCtxSize);
+   pmllDbParams_p->sreSessionCtxNum  = PMP_PMHWTOHL(sreSessionCtxNum);
+   pmllDbParams_p->sreRuleNum        = PMP_PMHWTOHL(sreRuleNum);
+     
+   return true;
+} /* _pmcd_target_params_get */
+
+/*
+ * Converts the passed string to an IPv4 address.
+ *
+ * param addrString_p  Pointer to the string with the address value.
+ * param address_p     Pointer to where to store the converted address.
+ * param port_p        Pointer to where to store the converted port.
+ * retval              True upon success; false otherwise.
+ */
+static bool _pmcd_ipv4if_address_from_string_get(const char      *addrString_p,
+                                                 uint32_t *const  address_p,
+                                                 uint16_t *const  port_p)
+{
+   uint32_t        address          = 0;
+   char           *end_p            = NULL;
+   char           *addrStringCopy_p = NULL;
+   char           *portString_p     = NULL;
+   bool            returnValue      = false;
+   struct in_addr  inAddr;
+   
+   addrStringCopy_p = strdup(addrString_p);
+
+   if (addrStringCopy_p == NULL)
+   {
+      /* We failed to duplicate the address string. */
+      return false;
+   }
+   
+   /* First check if the port is specified. */
+   portString_p = strchr(addrStringCopy_p, ':');
+
+   if (portString_p != NULL)
+   {
+      /* The port is specified.  Adjust the address and port strings. */
+      *portString_p = 0;
+      portString_p++;
+   }
+   
+     
+   /* Try to extract the IPv4 address first.  Assume that the value of
+    * the address is in a numeric form. */
+   address = strtoul(addrStringCopy_p, &end_p, 0);
+
+   if ((addrStringCopy_p != NULL) && (end_p == NULL))
+   {
+      *address_p  = ntohl(address);
+      returnValue = true;
+   }
+   else
+   {
+      /* Assume that the address is in the standard numbers-and-dots
+       * notation. */
+      if (inet_aton(addrStringCopy_p, &inAddr) != 0)
+      {
+         *address_p  = ntohl(inAddr.s_addr);
+         returnValue = true;
+      }
+      else
+      {
+         /* Assume that the string is a name of a host. */
+         struct hostent *hostent_p = gethostbyname2(addrStringCopy_p, AF_INET);
+
+         if (hostent_p != NULL)
+         {    
+            *address_p  = ntohl(((struct in_addr *)hostent_p->h_addr_list[0])->s_addr);
+            returnValue = true;
+         }
+      }
+   }
+   
+   /* Now try to extract the IPv4 port number. */
+   if (portString_p != NULL)
+   {
+      uint32_t tmpValue = 0;
+      
+      if ((cli_uint32get(portString_p, &tmpValue) == false) ||
+          (tmpValue > 0xffff))
+      {
+         returnValue = false;
+      }
+      else
+      {
+         *port_p = tmpValue;
+      }
+   }
+   
+   /* Free the duplicated string. */
+   if (addrStringCopy_p != NULL)
+   {
+      free(addrStringCopy_p);
+   }
+       
+   return returnValue;
+} /* _pmcd_ipv4if_address_from_string_get */
+
+/* 
+ * Get the presentation form of an IPv4 address.
+ *
+ * param ipv4Address    Numeric form of the IPv4 address.
+ * param ipv4Address_p  Pointer to the buffer where the presentation
+ *                      form of the IPv4 address is going to be
+ *                      stored.  The buffer must be at least the
+ *                      INET_ADDRSTRLEN bytes long. 
+ * retval               Pointer to passed in ipv4Address_p buffer
+ *                      with the presentation form of the address.
+ *                      The buffer contains an empty string, i.e, "",
+ *                      upon an error.
+ */
+static char *_pmcd_ipv4if_string_from_address_get(uint32_t  ipv4Address,
+                                                  char     *ipv4Address_p)
+{
+   uint32_t ipv4AddressNet = htonl(ipv4Address);
+ 
+   if (ipv4Address_p == NULL)
+   {
+      LOG_PRINT("%s: NULL ipv4Address_p passed.\n", __func__);
+      return ipv4Address_p;
+   }
+ 
+   if (inet_ntop(AF_INET,
+                 &ipv4AddressNet,
+                 ipv4Address_p,
+                 INET_ADDRSTRLEN) == NULL)
+   {
+      ipv4Address_p[0] = 0; 
+   }
+   
+   return ipv4Address_p;
+} /* _pmcd_ipv4if_string_from_address_get */
+
+/* 
+ * Create a PMLA connection to the PM H/W.
+ *
+ * This function attempts to create a control connection to communicate
+ * with the PM H/W identified by the ipv4Address, ipv4Port and
+ * channelId parameters.  The function assumes that an IPv4 address
+ * and port combined with the channel ID are used to identify the PM
+ * target. 
+ *
+ * param ipv4Address  IPv4 address of the PM target host.
+ * param ipv4Port     IPv4 port of the PM target host.
+ * param channelId    Part of the local address; ID of the PM H/W channel.
+ * param timeout      The timeout to be associated with the connection.
+ *                    This timeout is used while trying to receive PMLA
+ *                    messages. 
+ * param handle_p     Pointer to the area where the handle of the
+ *                    created control connection is to be stored.
+ * retval             pmlaSuccess_c upon success; a PMLA error code
+ *                    otherwise.  When PMLA_Ok_e is returned the
+ *                    handle of the created connection is returned
+ *                    through the handle_p parameter.
+ */
+static PmlaError_t _pmcd_pmla_connection_create(uint32_t  ipv4Address,
+                                                uint16_t  ipv4Port,
+                                                uint32_t  channelId,
+                                                uint32_t  timeout,
+                                                handle_t *handle_p)
+{
+   char                ipv4Address_s[INET_ADDRSTRLEN] = "";
+   PmlaError_t         pmlaStatus                     = pmlaSuccess_c;
+   PmlaTarget_t        pmlaTargetAddress;
+   struct sockaddr_in *inetAddr_p                     = (struct sockaddr_in *)&pmlaTargetAddress.addr;
+ 
+   /* Build the PMLA target address structure. */
+   memset(&pmlaTargetAddress, 0, sizeof(pmlaTargetAddress));
+
+   pmlaTargetAddress.channel   = channelId;
+   inetAddr_p->sin_family      = AF_INET;
+   inetAddr_p->sin_port        = htons(ipv4Port);
+   inetAddr_p->sin_addr.s_addr = htonl(ipv4Address);
+    
+   /* Create the PMLA target object. */
+   pmlaStatus = pmlaOpen(&pmlaTargetAddress, handle_p);
+
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      /* There was an error. */
+      LOG_PRINT("Failed to open a PMLA connection.  %s\n",
+                pmlaErrorString(pmlaStatus));
+      return pmlaStatus;
+   }
+   
+   /* Set the timeout value for the PMLA connection. */
+   pmlaStatus = pmlaSetOption(*handle_p, pmlaOptionTimeout_c, 
+                              &timeout, sizeof(timeout));
+
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      LOG_PRINT("Failed to set the timeout value to %u on a PMLA connection to "
+                "PM H/W target with ipv4Address=%s, ipv4Port=%u and "
+                "channelId=%u.  %s\n", 
+                timeout,
+                _pmcd_ipv4if_string_from_address_get(ipv4Address, ipv4Address_s),
+                ipv4Port,
+                channelId,
+                pmlaErrorString(pmlaStatus));
+   }
+   else
+   {
+      /* Connect to the PM H/W target. */
+      pmlaStatus = pmlaConnect(*handle_p);
+
+      if (pmlaStatus != pmlaSuccess_c)
+      {
+         LOG_PRINT("Failed to connect to PM H/W target with ipv4Address=%s, "
+                   "ipv4Port=%u and channelId=%u.  %s\n", 
+                   _pmcd_ipv4if_string_from_address_get(ipv4Address, 
+                                                        ipv4Address_s),
+                   ipv4Port,
+                   channelId,
+                   pmlaErrorString(pmlaStatus));
+      }
+      else
+      {
+         /* We successfully connected to the PM H/W target.  Now we
+          * set the keep alive interval for this connection. */
+         int  keepAliveInterval = _PMCD_PMLA_KEEP_ALIVE_INTERVAL;
+
+         pmlaStatus = pmlaSetOption(*handle_p, pmlaOptionKeepAlive_c, 
+                                    &keepAliveInterval, 
+                                    sizeof(keepAliveInterval));
+
+         if (pmlaStatus != pmlaSuccess_c)
+         {
+            LOG_PRINT("Failed to set the keep alive interval to %d on a PMLA "
+                      "connection to PM H/W target with ipv4Address=%s, "
+                      "ipv4Port=%u and channelId=%u.  %s\n",
+                      keepAliveInterval, 
+                      _pmcd_ipv4if_string_from_address_get(ipv4Address, 
+                                                           ipv4Address_s),
+                      ipv4Port,
+                      channelId,
+                      pmlaErrorString(pmlaStatus));
+         }
+      }
+   }
+ 
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      /* The function failed.  Close the connection. */
+      PmlaError_t  pmlaCloseStatus = pmlaClose(*handle_p);
+
+      *handle_p = HANDLE_NULL;
+
+      if (pmlaCloseStatus != pmlaSuccess_c)
+      {
+         LOG_PRINT("Failed to close a PMLA connection opened to PM H/W target "
+                   "with ipv4Address=%s, ipv4Port=%u and channelId=%u. %s\n",
+                   _pmcd_ipv4if_string_from_address_get(ipv4Address, 
+                                                        ipv4Address_s),
+                   ipv4Port,
+                   channelId,
+                   pmlaErrorString(pmlaCloseStatus));
+      }
+   }
+   else
+   {
+      LOG_PRINT("Successfully created a PMLA connection to PM H/W (handle=%"PRI_HANDLE").\n",
+                *handle_p);
+   }
+   
+   return pmlaStatus;
+} /* _pmcd_pmla_connection_create */
+
+/* Create a PMCD database.
+ *
+ * param appParams_p  Parameters for pmcd application and this DB.
+ *
+ * retval             Handle of the newly created PMCD DB upon success,
+ *                    a NULL handle otherwise.
+ */
+static handle_t _pmcd_db_create(_pmcd_app_params_t *appParams_p)
+{
+   PmlaError_t       pmlaStatus = pmlaSuccess_c;
+   bool              statusOk   = true;
+   pmll_status_t     pmllStatus = pmll_ok_e;
+   db_status_t       dbStatus   = db_ok_e;
+   uint32_t          patternMax = 0;
+   uint32_t          ruleMax    = 0;
+   _pmcd_db_t       *pmcdDb_p   = NULL;
+   pmll_db_params_t  pmllDbParams;
+   int               count;
+ 
+   memset(&pmllDbParams, 0, sizeof(pmll_db_params_t));
+ 
+   pmcdDb_p = (_pmcd_db_t *)calloc(1, sizeof(_pmcd_db_t));
+ 
+   if (pmcdDb_p == NULL)
+   {
+      LOG_PRINT("Failed to allocate %d bytes of memory needed for PMCD DB\n",
+                (int)sizeof(_pmcd_db_t));
+      return HANDLE_NULL;
+   }
+ 
+   /* Reset the PMCD DB. */
+   pmcdDb_p->llDbHandle        = _PMCD_NULL_PMLL_DB_HANDLE;
+   pmcdDb_p->pmlaForPmllHandle = HANDLE_NULL;
+   pmcdDb_p->pmlaForPmcdHandle = HANDLE_NULL;
+   pmcdDb_p->expDbHandle       = HANDLE_NULL;
+   pmcdDb_p->ruleDbHandle      = HANDLE_NULL;
+   pmcdDb_p->option8572rev1_0  = appParams_p->option8572rev1_0Flag;
+ 
+   for (count = 0; count < _PMCD_NUM_SETS; count++)
+   {
+      dll_list_init(&((pmcdDb_p->set)[count]));
+   }
+
+   /* Create a PMLA connection to the PM H/W to be used by the PMCD. */
+   pmlaStatus = _pmcd_pmla_connection_create(appParams_p->targetIpv4Address, 
+                                             appParams_p->targetIpv4Port, 
+                                             appParams_p->targetChannelId,
+                                             appParams_p->pmlaChannelTimeout, 
+                                             &pmcdDb_p->pmlaForPmcdHandle);
+
+   if (pmlaStatus != pmlaSuccess_c)
+   {
+      LOG_PRINT("Failed to create PMLA control channel for use by PMCD. %s\n",
+                pmlaErrorString(pmlaStatus));
+      statusOk = false;
+   }
+ 
+ 
+   /* Retrieve the target specific parameters requried to create a PMLL DB. */
+   if (statusOk == true)
+   {
+      if (appParams_p->hwSimFlag == true)
+      {
+         /* The H/W simulation mode is on.  We use a predefined values
+          * for the DB parameters.  Note that the H/W simulation on this
+          * level is an unsupported feature and can be removed at any
+          * time.  We use constants and not macros to emphasize the
+          * volatality of the H/W simulation feature. */
+         switch(appParams_p->hwSimRevision)
+         {
+#ifdef PME_1_1
+            case PM_PME_VERSION_1_1:
+               pmllDbParams.dxeSreTableSize   = 65536;
+               pmllDbParams.sreSessionCtxSize = 32768;
+               pmllDbParams.sreSessionCtxNum  = 1024;
+               pmllDbParams.sreRuleNum        = PM_STATEFUL_RULE_MAX_NUM_V1;
+               break;
+#endif
+#ifdef PME_2_0
+            case PM_PME_VERSION_2_0:
+               pmllDbParams.dxeSreTableSize   = 65536*4;
+               pmllDbParams.sreSessionCtxSize = 128*1024;
+               pmllDbParams.sreSessionCtxNum  = 1024;
+               pmllDbParams.sreRuleNum        = PM_STATEFUL_RULE_MAX_NUM_V2_0;
+               break;
+#endif
+#ifdef PME_2_1
+            case PM_PME_VERSION_2_1:
+               pmllDbParams.dxeSreTableSize   = 65536*4;
+               pmllDbParams.sreSessionCtxSize = 128*1024;
+               pmllDbParams.sreSessionCtxNum  = 1024;
+               pmllDbParams.sreRuleNum        = PM_STATEFUL_RULE_MAX_NUM_V2_1;
+               break;
+#endif
+            default:
+               LOG_PRINT("Unable to simulate HW revision %x\n",
+                         appParams_p->hwSimRevision);
+              return HANDLE_NULL;
+         }
+
+         pmllDbParams.hwRevision = appParams_p->hwSimRevision;
+
+         if (appParams_p->hwSimSreCfgOptSetFlag == true)
+         {
+            pmllDbParams.sreSessionCtxSize = appParams_p->hwSimCtxSize;
+            pmllDbParams.sreRuleNum        = appParams_p->hwSimRuleNum;
+         }
+      }
+      else
+      {
+         statusOk = _pmcd_target_params_get(pmcdDb_p->pmlaForPmcdHandle,
+                                            &pmllDbParams);
+
+         if (statusOk == false)
+         {
+            LOG_PRINT("Failed to retrieve platform specific DB parameters.\n");
+         }
+      }
+   }
+   
+   if (statusOk == true)
+   {
+      switch(pmllDbParams.hwRevision)
+      {
+#ifdef PME_1_1
+         case PM_PME_VERSION_1_1:
+            patternMax = PM_PATTERN_MAX_NUM_V1;
+            ruleMax    = PM_STATEFUL_RULE_MAX_NUM_V1;
+            break;
+#endif
+#ifdef PME_2_0
+         case PM_PME_VERSION_2_0:
+            patternMax = PM_PATTERN_MAX_NUM_V2_0;
+            ruleMax    = PM_STATEFUL_RULE_MAX_NUM_V2_0;
+            break;
+#endif
+#ifdef PME_2_1
+         case PM_PME_VERSION_2_1:
+            patternMax = PM_PATTERN_MAX_NUM_V2_1;
+            ruleMax    = PM_STATEFUL_RULE_MAX_NUM_V2_1;
+            break;
+#endif
+         default:
+            LOG_PRINT("Unsupported HW revision %08x\n",
+                      pmllDbParams.hwRevision);
+            statusOk = false;
+      }
+   }
+ 
+   /* Create the PMCD expression DB. */
+   if (statusOk == true)
+   {
+      dbStatus = db_db_create(patternMax,
+                              "PMCD expression DB",
+                              &pmcdDb_p->expDbHandle);
+
+      if (dbStatus != db_ok_e)
+      {
+         LOG_PRINT("Failed to create the PMCD expression DB. %s\n",
+                   db_error_string_get(dbStatus));
+         statusOk = false;
+      }
+   }
+ 
+   if (statusOk == true)
+   {
+      /* Create the PMCD rule DB. */
+      dbStatus = db_db_create(ruleMax,
+                              "PMCD rule DB", 
+                              &pmcdDb_p->ruleDbHandle);
+
+      if (dbStatus != db_ok_e)
+      {
+         LOG_PRINT("Failed to create the PMCD rule DB. %s\n", 
+                db_error_string_get(dbStatus));
+         statusOk = false;
+      }
+   }
+ 
+   if (statusOk == true)
+   {
+      /* Create the PMLL DB. */
+      pmllDbParams.pmlaFunctions.pmlaBulkBeginFunction_p      = pmlaSendBulkBegin;
+      pmllDbParams.pmlaFunctions.pmlaBulkEndFunction_p        = pmlaSendBulkEnd;
+      pmllDbParams.pmlaFunctions.pmlaFlushFunction_p          = pmlaFlush;
+      pmllDbParams.pmlaFunctions.pmlaReadFunction_p           = pmlaRecv;
+      pmllDbParams.pmlaFunctions.pmlaWriteFunction_p          = pmlaSend;
+      pmllDbParams.pmlaFunctions.pmlaErrorStringGetFunction_p = pmlaErrorString; 
+  
+      pmllStatus = pmll_db_create(&pmllDbParams, &pmcdDb_p->llDbHandle);
+
+      if (pmllStatus != pmll_ok_e)
+      {
+         LOG_PRINT("Failed to create the PMLL DB. %s\n", 
+                   pmll_error_string_get(pmllStatus));
+         statusOk = false;
+      }
+   }
+ 
+   if (statusOk == true)
+   {
+      /* Create a PMLA connection to the PM H/W and associate the handle
+       * of this connection with the created PMLL DB. */
+      pmlaStatus = _pmcd_pmla_connection_create(appParams_p->targetIpv4Address, 
+                                                appParams_p->targetIpv4Port, 
+                                                appParams_p->targetChannelId,
+                                                appParams_p->pmlaChannelTimeout, 
+                                                &pmcdDb_p->pmlaForPmllHandle);
+
+      if (pmlaStatus != pmlaSuccess_c)
+      {
+         LOG_PRINT("Failed to create PMLA control channel for use by PMCD. %s\n",
+                   pmlaErrorString(pmlaStatus));
+         statusOk = false;
+      }
+      else
+      {
+         pmllStatus = pmll_connection_handle_set(pmcdDb_p->llDbHandle, 
+                                                 pmcdDb_p->pmlaForPmllHandle);
+
+         if (pmllStatus != pmll_ok_e)
+         {
+            LOG_PRINT("Failed to set the PMLA control channel handle in PMLL DB. %s\n",
+                      pmll_error_string_get(pmllStatus));
+           statusOk = false;
+         }
+      }
+   }
+ 
+   if (statusOk == true)
+   {
+      return pmcdDb_p;
+   }
+   else
+   {
+      (void)_pmcd_db_destroy(pmcdDb_p);
+   }
+ 
+   return HANDLE_NULL;
+} /* _pmcd_db_create */
+
+/* -------------------------------------------------------------------------- *
+ * Setup and initialize the database components
+ * -------------------------------------------------------------------------- */
+static pmc_status_t _pmcd_setup(_pmcd_app_params_t *appParams_p)
+{
+   idx_status_t        idxStatus  = idx_error_e;
+   db_status_t         dbStatus   = db_error_e;
+   pmll_status_t       pmllStatus = pmll_error_e;
+
+   /* Initialize the IDX module. */
+   idxStatus = idx_module_init();
+
+   if (idxStatus != idx_ok_e)
+   {
+      LOG_PRINT("Failed to initialize the IDX module. %s\n",
+                idx_error_string_get(idxStatus));
+      return pmc_init_fail_e;
+   }
+
+   /* Initialize the DB module. */
+   dbStatus = db_module_init();
+
+   if (dbStatus != db_ok_e)
+   {
+      LOG_PRINT("Failed to initialize the DB module. %s\n",
+                db_error_string_get(dbStatus));
+      return pmc_init_fail_e;
+   }
+
+   /* Initialize the PMLL module. */
+   pmllStatus = pmll_module_init(_PMCD_INITIAL_PMLL_HANDLE_TABLE_SIZE, true);
+
+   if (pmllStatus != pmll_ok_e)
+   {
+      LOG_PRINT("Failed to initialize the PMLL module. %s\n",
+                pmll_error_string_get(pmllStatus));
+      return pmc_init_fail_e;
+   }
+ 
+   /* Create the PMCD DB. */
+   _pmcd_db_handle_sg = _pmcd_db_create(appParams_p);
+
+   if (_pmcd_db_handle_sg == HANDLE_NULL)
+   {
+      LOG_PRINT("Failed to create the PMCD DB.\n");
+      return pmc_init_fail_e;
+   }
+   else
+   {
+      LOG_PRINT("Successfully created the PMCD DB.\n");
+   }
+ 
+   return pmc_ok_e;
+}
+
+/* -------------------------------------------------------------------------- *
+ * Show help
+ * -------------------------------------------------------------------------- */
+static void _pmcd_help_show(char *appName_p)
+{
+  char *name_p                         = strdup(appName_p);
+  char *baseName_p                     = appName_p;
+  char  ipv4Address_s[INET_ADDRSTRLEN] = "";
+
+  if (name_p != NULL)
+  {
+    baseName_p = basename(name_p);
+  }
+  
+  fprintf(stdout, "Usage:");
+  fprintf(stdout, "\n\t%s [<options>]", baseName_p);
+  fprintf(stdout, "\n\n");
+
+  fprintf(stdout, "Supported PME revision:");
+#ifdef PME_1_1
+  fprintf(stdout, "\n\t8572 PME 1.1");
+#endif
+#ifdef PME_2_0
+  fprintf(stdout, "\n\t8578 PME 2.0");
+#endif
+  fprintf(stdout, "\n\n");
+
+  fprintf(stdout, "Options:");  
+  fprintf(stdout, "\n  %s, %s <id>"
+          "\n\tSet the target channel ID to be used.  The default channel"
+          "\n\tID is %u.\n", 
+          _PMCD_CMD_ARG_SHORT_TARGET_CHANNEL, _PMCD_CMD_ARG_LONG_TARGET_CHANNEL,
+          _PMCD_PMLA_TARGET_CHANNEL_ID);
+  fprintf(stdout, "\n  %s, %s"
+          "\n\tTurn on the exit-on-error flag.  This flag makes the "
+          "\n\t%s application terminate upon encountering an error.  "
+          "\n\tThis behavior could be useful in situations when the "
+          "\n\t%s application runs in a non-interactive mode."
+          "\n\tNote that, if present, the commands in the PMLL debug "
+          "\n\tsub-menu do not currently implement this option.\n", 
+          _PMCD_CMD_ARG_SHORT_EXIT_ON_ERROR, _PMCD_CMD_ARG_LONG_EXIT_ON_ERROR, 
+          baseName_p, baseName_p);
+  fprintf(stdout, "\n  %s, %s"
+          "\n\tDisplay this help information.\n", 
+          PMAPP_CmdArgShortHelp_d, PMAPP_CmdArgLongHelp_d);
+  fprintf(stdout, "\n  %s, %s <filename>"
+          "\n\tSet the name of the log file.  If this option is not "
+          "\n\tspecified, no logs are generated.\n", 
+          PMAPP_CmdArgShortLogFile_d, PMAPP_CmdArgLongLogFile_d);
+  fprintf(stdout, "\n  %s <level>"
+          "\n\tSet the logging level to the specified value.\n", 
+          PMAPP_CmdArgLongLogLevel_d);
+  fprintf(stdout, "\n  %s <ipv4address|hostname>[:<ipv4port>]"
+          "\n\tSet the address of the PM H/W remote target.  The default "
+          "\n\tIPv4 address is %s and the default port is %d.  "
+          "\n\tNote that if the PM H/W is locally connected this option "
+          "\n\thas no meaning. \n", 
+          _PMCD_CMD_ARG_TARGET_ADDRESS,
+          _pmcd_ipv4if_string_from_address_get(_PMCD_PMLA_TARGET_IP_ADDRESS,
+                                              ipv4Address_s), 
+          _PMCD_PMLA_TARGET_IP_PORT);
+#ifdef PME_1_1
+  fprintf(stdout, "\n  %s"
+          "\n\tCompile for 8572 rev 1.0 silicon.", _PMCD_CMD_ARG_8572_REV_1_0);
+  fprintf(stdout, "\n\n");
+#endif
+
+  fprintf(stdout, "Example:");
+  fprintf(stdout, "\n\t%s %s /dev/stdout %s -1\n", baseName_p, 
+          PMAPP_CmdArgShortLogFile_d, PMAPP_CmdArgLongLogLevel_d);
+  fprintf(stdout, "\n");
+
+
+  free(name_p);
+} /* _pmcd_help_show */
+
+/* -------------------------------------------------------------------------- *
+ * Process command line arguments.
+ * -------------------------------------------------------------------------- */
+static int _pmcd_process_args (int                 argn,
+                               char               *args[],
+                               _pmcd_app_params_t *appParams_p)
+{
+  int   arg            = 1;
+  char *tooFewParams_s = "Insufficient number of parameters for the \"%s\" option.\n";
+
+  /* Initialize the application argument values. */
+  memset(appParams_p, 0, sizeof(_pmcd_app_params_t));
+
+  appParams_p->hwSimFlagOptSetFlag   = false;
+  appParams_p->logLevelOptSetFlag    = false;
+  appParams_p->logFileNameOptSetFlag = false;
+  appParams_p->targetOptSetFlag      = false;
+  appParams_p->hwSimFlag             = false;
+  appParams_p->hwSimRevision         = 0;
+  appParams_p->hwSimCtxSize          = 0;
+  appParams_p->hwSimRuleNum          = 0;
+  appParams_p->exitOnErrorFlag       = false;
+  appParams_p->option8572rev1_0Flag  = false;
+  appParams_p->logLevel              = PMAPP_DefaultLogLevel_d;
+  appParams_p->logFileName_p         = _PMCD_DEFAULT_LOG_FILE;
+  appParams_p->targetIpv4Address     = _PMCD_PMLA_TARGET_IP_ADDRESS;
+  appParams_p->targetIpv4Port        = _PMCD_PMLA_TARGET_IP_PORT;
+  appParams_p->targetChannelId       = _PMCD_PMLA_TARGET_CHANNEL_ID;
+  appParams_p->pmlaChannelTimeout    = _PMCD_PMLA_TIMOUT;
+
+
+   /* Walk through all the command line arguments */
+   while (arg < argn)
+   {
+      if (strcmp(args[arg], _PMCD_CMD_ARG_PM_hw_simulation) == 0)
+      {
+         appParams_p->hwSimFlagOptSetFlag = true;
+         appParams_p->hwSimFlag           = true;
+         arg++;
+         if(arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, _PMCD_CMD_ARG_PM_hw_simulation);
+            return -1;
+         }
+
+         if (strcmp(args[arg], _PMCD_CMD_PARA_PM_hw_simulation_1_1) == 0)
+         {
+            appParams_p->hwSimRevision = PM_PME_VERSION_1_1;
+         }
+         else if (strcmp(args[arg], _PMCD_CMD_PARA_PM_hw_simulation_2_0) == 0)
+         {
+            appParams_p->hwSimRevision = PM_PME_VERSION_2_0;
+         }
+         else if (strcmp(args[arg], _PMCD_CMD_PARA_PM_hw_simulation_2_1) == 0)
+         {
+            appParams_p->hwSimRevision = PM_PME_VERSION_2_1;
+         }
+         else
+         {
+            fprintf(stdout, "Simulating PME HW revision %s is not supported\n",
+                    args[arg]);
+            return -1;
+         }
+      }
+      else if (strcmp(args[arg], _PMCD_CMD_ARG_PM_hw_sim_sre_cfg) == 0)
+      {
+         appParams_p->hwSimSreCfgOptSetFlag = true;
+         arg++;
+         if(arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, args[arg - 1]);
+            return -1;
+         }
+
+         if (cli_uint32get(args[arg], &appParams_p->hwSimCtxSize) == false   ||
+             appParams_p->hwSimCtxSize % PMP_SESSION_CONTEXT_ENTRY_SIZE != 0 ||
+             appParams_p->hwSimCtxSize == 0)
+         {
+            fprintf(stdout, "The session context size \"%s\" is invalid.\n",
+                    args[arg]);
+            return -1;
+         }
+
+         arg++;
+
+         if(arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, args[arg - 2]);
+            return -1;
+         }
+
+         if (cli_uint32get(args[arg], &appParams_p->hwSimRuleNum) == false ||
+             appParams_p->hwSimRuleNum == 0)
+         {
+            fprintf(stdout, "The rule number \"%s\" is invalid.\n",
+                    args[arg]);
+            return -1;
+         }
+      }
+      else if ((strcmp(args[arg], _PMCD_CMD_ARG_SHORT_EXIT_ON_ERROR) == 0) ||
+               (strcmp(args[arg], _PMCD_CMD_ARG_LONG_EXIT_ON_ERROR) == 0))
+      {
+         appParams_p->exitOnErrorFlag = true;
+      }
+      else if ((strcmp(args[arg], PMAPP_CmdArgShortHelp_d) == 0) ||
+               (strcmp(args[arg], PMAPP_CmdArgLongHelp_d) == 0))
+      {
+         _pmcd_help_show(args[0]);
+         return -1;
+      }
+      else if (strcmp(args[arg], PMAPP_CmdArgLongLogLevel_d) == 0)
+      {
+         appParams_p->logLevelOptSetFlag = true;
+
+         /* Try to get the log level value. */
+         arg++;
+
+         if(arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, PMAPP_CmdArgLongLogLevel_d);
+            return -1;
+         }
+
+         if (cli_uint32get(args[arg], &appParams_p->logLevel) == false)
+         {
+            fprintf(stdout, "The log level value of \"%s\" is invalid.\n",
+                    args[arg]);
+            return -1;
+         }
+      }
+      else if ((strcmp(args[arg], PMAPP_CmdArgShortLogFile_d) == 0) ||
+               (strcmp(args[arg], PMAPP_CmdArgLongLogFile_d) == 0))
+      {
+         appParams_p->logFileNameOptSetFlag = true;
+
+         /* Try to get the log file name. */
+         arg++;
+
+         if(arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, args[arg - 1]);
+            return -1;
+         }
+
+         appParams_p->logFileName_p = strdup(args[arg]);
+
+         if (appParams_p->logFileName_p == NULL)
+         {
+            fprintf(stdout, "Failed to allocate memory for the log file name.\n");
+            return -1;
+         }
+      }
+      else if (strcmp(args[arg], _PMCD_CMD_ARG_TARGET_ADDRESS) == 0)
+      {
+         appParams_p->targetOptSetFlag = true;
+
+         /* Try to get the IPv4 address and optionally port values. */
+         arg++;
+
+         if (arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, _PMCD_CMD_ARG_TARGET_ADDRESS);
+            return -1;
+         }
+
+         if (_pmcd_ipv4if_address_from_string_get(args[arg],
+                                                  &appParams_p->targetIpv4Address, 
+                                                  &appParams_p->targetIpv4Port) == false)
+         {
+            fprintf(stdout, "The address[:port] value of \"%s\" is invalid.\n", 
+                    args[arg]);
+            return -1;
+         }
+      }
+      else if ((strcmp(args[arg], _PMCD_CMD_ARG_SHORT_TARGET_CHANNEL) == 0) ||
+               (strcmp(args[arg], _PMCD_CMD_ARG_LONG_TARGET_CHANNEL) == 0))
+      {
+         /* Try to get the channel ID value. */
+         arg++;
+
+         if (arg >= argn)
+         {
+            fprintf(stdout, tooFewParams_s, args[arg - 1]);
+            return -1;
+         }
+
+         if (cli_uint32get(args[arg], &appParams_p->targetChannelId) == false)
+         {
+            fprintf(stdout, "The channel ID value of \"%s\" is invalid.\n",
+                    args[arg]);
+            return -1;
+         }
+      }
+      else if (strcmp(args[arg], _PMCD_CMD_ARG_8572_REV_1_0) == 0)
+      {
+         appParams_p->option8572rev1_0Flag = true;
+      }
+      else
+      {
+         fprintf(stdout, "Invalid argument: \"%s\"\n", args[arg]);
+         _pmcd_help_show(args[0]);
+         return -1;
+      }
+      
+      arg++;
+   }
+ 
+   /* If the H/W simulation mode is on we need to set the target
+    * channel value to be negative.  Note that H/W simulation on this
+    * level is an unsupported feature and can be removed at any time. */
+   if (appParams_p->hwSimFlag == true)
+   {
+     /* Turn on the PM H/W simulation.  Keep in mind that this is a
+      * partial simulation. */
+     appParams_p->targetChannelId = -1;
+   }
+   
+   return 0;
+}
+
+/* -------------------------------------------------------------------------- *
+ *                                 MAIN
+ * -------------------------------------------------------------------------- */
+int main (int argn, char *args[])
+{
+   int                  server_sock_fd;
+   int                  len;
+   int                  rc;
+   struct sockaddr_un   server_address;
+   dll_list_t           client_list;
+   struct sigaction     int_action;
+   _pmcd_command_t    **command_table_p; // Table of _pmcd_command_t
+   _pmcd_app_params_t   app_params;
+
+   /* Before doing anything else, get a log file open so we can
+    * log any problems or information.  */
+   _pmc_log_stream_pg = fopen(_PMCD_DEFAULT_LOG_FILE, "w");
+
+   if (_pmc_log_stream_pg == NULL)
+   {
+      fprintf(stderr,
+              "Could not open log file ->%s<- for pmcd:\n%s\n",
+              _PMCD_DEFAULT_LOG_FILE,
+              strerror(errno));
+      _pmcd_cleanup();
+   }
+
+   /* Process command line arguments */
+   if (_pmcd_process_args(argn, args, &app_params) != 0)
+   {
+      _pmcd_cleanup();
+   }
+
+   /* Catch signals */
+
+   memset(&int_action, 0, sizeof(int_action));
+
+   int_action.sa_sigaction = &_pmcd_int_sig_handler;
+
+   if (sigaction(SIGINT, &int_action, NULL) != 0)
+   {
+      LOG_PRINT("Failed to install signal handler for SIGINT: %s\n",
+                strerror(errno));
+
+      /* This is not fatal, so keep going */
+   }
+
+   memset(&int_action, 0, sizeof(int_action));
+
+   int_action.sa_sigaction = &_pmcd_pipe_sig_handler;
+
+   if (sigaction(SIGPIPE, &int_action, NULL) != 0)
+   {
+      LOG_PRINT("Failed to install signal handler for SIGPIPE: %s\n",
+                strerror(errno));
+
+      /* This one is fatal, so cleanup. */
+      _pmcd_cleanup();
+   }
+
+   LOG_PRINT("Launching\n");
+
+   /* Initialization */
+   dll_list_init(&client_list);
+
+   command_table_p = (_pmcd_command_t **)calloc(sizeof(_pmcd_command_t *) * _pmc_cmd_max_e, 1);
+
+   if (command_table_p == NULL)
+   {
+      LOG_PRINT("Failed to create command table\n");
+      _pmcd_cleanup();
+   }
+
+   /* Register all the command functions */
+   _pmcd_register_command_functions(command_table_p);
+
+   /* Create socket */
+   server_sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+
+   if (server_sock_fd < 0)
+   {
+      LOG_PRINT("Failed to create server socket: %s\n",
+               strerror(errno));
+      _pmcd_cleanup();
+   }
+
+   /* Bind socket to a file */
+   server_address.sun_family = AF_UNIX;
+
+   strncpy(server_address.sun_path,
+           SERVER_SOCK_FILE_PATH,
+           UNIX_PATH_MAX);
+
+   rc = unlink(server_address.sun_path);
+
+   if (rc != 0)
+   {
+      /* No file is OK, but anything else is an error */
+      if (errno != ENOENT)
+      {
+         LOG_PRINT("Failed to remove old socket file ->%s<-: %s\n",
+                   server_address.sun_path,
+                   strerror(errno));
+         _pmcd_cleanup();
+      }
+   }
+
+   len = strlen(server_address.sun_path) + sizeof(server_address.sun_family);
+
+   if (bind(server_sock_fd, (struct sockaddr *)&server_address, len) != 0)
+   {
+      LOG_PRINT("Failed to bind server socket to file ->%s<-: %s\n",
+                server_address.sun_path,
+                strerror(errno));
+      _pmcd_cleanup();
+   }
+
+   /* Mark this socket as a listen socket for the server */
+   if (listen(server_sock_fd, _PMCD_DEFAULT_MAX_CONNECTION_BACKLOG) != 0)
+   {
+      LOG_PRINT("Failed to mark server socket as a listen socket: %s\n",
+                strerror(errno));
+      _pmcd_cleanup();
+   }
+ 
+   /* Set socket to nonblocking */
+   if (_pmcd_set_nonblock(server_sock_fd) != 0)
+   {
+      _pmcd_cleanup();
+   }
+
+   /* Setup and initialize the database components */
+   if (_pmcd_setup(&app_params) != pmc_ok_e)
+   {
+      _pmcd_cleanup();
+   }
+
+   /* Switch to daemon mode */
+   if (daemon(0,0) != 0)
+   {
+      LOG_PRINT("Failed to daemonize the server process: %s\n",
+                strerror(errno));
+      _pmcd_cleanup();
+   }
+
+   /* Server loop */
+   while (1)
+   {
+      fflush(_pmc_log_stream_pg);
+
+      /* ----------------------------------------------------------
+       * Get any new pending connections.
+       * ---------------------------------------------------------- */
+
+      if (_pmcd_accept_client(server_sock_fd, &client_list) != 0)
+      {
+         break;
+      }
+
+      /* ----------------------------------------------------------
+       * Get any new data from the clients.
+       * ---------------------------------------------------------- */
+
+      if (_pmcd_read_clients(&client_list) != 0)
+      {
+         break;
+      }
+
+      /* ----------------------------------------------------------
+       * Process any complete requests.
+       * ---------------------------------------------------------- */
+
+      if (_pmcd_process_requests(&client_list,
+                                 command_table_p) != 0)
+      {
+         break;
+      }
+
+      /* Wait for a new client or read data on an existing client */
+      if (_pmcd_wait_for_input(server_sock_fd, &client_list) != 0)
+      {
+         break;
+      }
+   }
+
+   _pmcd_cleanup();
+
+   return 0;
+}
diff --git a/pmConfiguration/pmcd.h b/pmConfiguration/pmcd.h
new file mode 100644
index 0000000..fbc68d0
--- /dev/null
+++ b/pmConfiguration/pmcd.h
@@ -0,0 +1,189 @@
+/************************< BEGIN COPYRIGHT >************************
+ *  
+ *   Copyright 2009, Freescale Semiconductor, Inc.  All Rights Reserved.
+ *  
+ *    NOTICE: The information contained in this file is proprietary 
+ *    to Freescale Semiconductor and is being made available to 
+ *    Freescale's customers under a specific license agreement. 
+ *    Use or disclosure of this information is permissible only 
+ *    under the terms of the license agreement. 
+ *  
+ * 
+ ************************< END COPYRIGHT >***************************/
+/****************************************************************************
+ *   File Name : pmcd.h
+ *   Author    : Vince Hendricks
+ *
+ *   This file defines the interface to the Pattern Matching Config Daemon.
+ ****************************************************************************/
+#ifndef PMCD_H_INCLUDE
+#define PMCD_H_INCLUDE
+
+/* Server default values */
+#define _PMCD_DEFAULT_MAX_CONNECTION_BACKLOG 10
+#define _PMCD_DEFAULT_LOG_FILE               "/tmp/pmcd.log"
+#define _PMCD_BUFFER_SIZE                    500
+#define _PMCD_MAX_DEC_SIZE                   25
+#define _PMCD_INITIAL_PMLL_HANDLE_TABLE_SIZE 128
+
+/* The next macro defines the default size of data messages that are
+ * sent to the PM H/W when scanning data for patterns. */
+#define _PMCD_DEFAULT_DATA_MSG_SIZE         8192
+
+
+/* The next two macros define the size of the pmcd name tables, e.g.,
+ * the expression and rule name tables.  The factor macro is used to
+ * determines the size of the name table.  The actual size of the name
+ * table is  2 ^ _PMCD_NAME_TABLE_SIZE_FACTOR, e.g., 2 ^ 10 = 1024.
+ * The size is defined through such a factor so that the name hashing
+ * factions can be adjusted automatically when the table size changes.
+ * In the current implementation of the hash function used for the
+ * names the maximum value for this macro is 16. */
+#define _PMCD_NAME_TABLE_SIZE_FACTOR        10
+#define _PMCD_NAME_TABLE_SIZE               (1 << _PMCD_NAME_TABLE_SIZE_FACTOR)
+
+
+/* This macro defines the maximum number of parameters in a CLI
+ * command. */
+#define _PMCD_PARAM_MAX_NUM                 32
+
+
+/* The next two macros define the maximum size of the expression and
+ * option strings as supported by the PMCD module. */
+#define _PMCD_NAME_STRING_MAX_SIZE          256
+#define _PMCD_EXP_STRING_MAX_SIZE           256
+#define _PMCD_EXP_OPTIONS_STRING_MAX_SIZE   256
+#define _PMCD_NUM_SETS                      256
+
+
+/* The following macros define the arguments that the PMCD application
+ * supports. */
+#define _PMCD_CMD_ARG_PM_hw_simulation      "--hwsim"
+#define _PMCD_CMD_ARG_PM_hw_sim_sre_cfg     "--hwsim-sre-cfg"
+#define _PMCD_CMD_PARA_PM_hw_simulation_1_1 "1.1"
+#define _PMCD_CMD_PARA_PM_hw_simulation_2_0 "2.0"
+#define _PMCD_CMD_PARA_PM_hw_simulation_2_1 "2.1"
+#define _PMCD_CMD_ARG_LONG_TARGET_CHANNEL   "--channel"
+#define _PMCD_CMD_ARG_SHORT_TARGET_CHANNEL  "-c"
+#define _PMCD_CMD_ARG_LONG_EXIT_ON_ERROR    "--exit-on-error"
+#define _PMCD_CMD_ARG_SHORT_EXIT_ON_ERROR   "-e"
+#define _PMCD_CMD_ARG_TARGET_ADDRESS        "--target"
+#define _PMCD_CMD_ARG_8572_REV_1_0          "--8572rev1.0"
+
+
+/* This macro defines the timeout (in seconds) interval used to
+ * receive all the PMLA messages. */
+#define _PMCD_PMLA_TIMOUT                   30
+
+
+/* This macro defines the keep alive interval (in seconds) that the
+ * PMLA module is configured with. */
+#define _PMCD_PMLA_KEEP_ALIVE_INTERVAL      60
+
+
+/* The next few macros define the IPv4 address, IPv4 port and the ID
+ * of the PM H/W channel to be used with the PMLA module to open a
+ * connection to the PM H/W. */
+#define _PMCD_PMLA_TARGET_IP_ADDRESS        0x7f000001
+#define _PMCD_PMLA_TARGET_IP_PORT           12345
+
+
+/* This macro defines the default PM H/W (DMA) channel ID. */
+#define _PMCD_PMLA_TARGET_CHANNEL_ID        0
+
+
+/* This macro defines the initial number of the PMLL DB handles. */
+#define _PMCD_INITIAL_PMLL_HANDLE_TABLE_SIZE 128
+
+
+/* This macro defines the NULL PMLL DB handle. */
+#define _PMCD_NULL_PMLL_DB_HANDLE           -1U
+
+
+/* Linked list node type for client sockets */
+typedef struct _pmcd_client_data
+{
+   dll_node_t  dll_node;
+   int         sock_fd;
+   uint32_t    read_buffer_size;
+   uint8_t    *read_buffer_p;
+   uint32_t    write_buffer_size;
+   uint8_t    *write_buffer_p;
+} _pmcd_client_data_t;
+
+/* Command type */
+typedef struct _pmcd_command
+{
+   // Function pointer.
+   //   Paramaters:  parameter data for command
+   //                response string from command
+   //
+   //   Returns: errno value (0 = sucess)
+   int  (*ftn_p)(uint8_t  *param_str_p,
+                 uint8_t **resp_str_p);
+} _pmcd_command_t;
+
+/* This type holds all pmcd application arguments. */
+typedef struct {
+   bool      hwSimFlagOptSetFlag;  /* hwSimFlag option set flag */
+   bool      hwSimSreCfgOptSetFlag;/* SRE configs for hwsim option set flag */
+   bool      logLevelOptSetFlag;   /* logLevel option set flag */
+   bool      logFileNameOptSetFlag;/* logFileName option set flag */
+   bool      targetOptSetFlag;     /* target option set flag */
+ 
+   bool      hwSimFlag;            /* simulate (in a limited way) the PM H/W */
+   uint32_t  hwSimRevision;        /* simulate PME HW revision */
+   uint32_t  hwSimCtxSize;         /* simulated session context size. */
+   uint32_t  hwSimRuleNum;         /* simulated max number of rules. */
+   bool      exitOnErrorFlag;      /* make PMCD exit upon an error. */
+   uint32_t  logLevel;             /* log level */
+   char     *logFileName_p;        /* name of the log file */
+   uint32_t  targetIpv4Address;    /* IPv4 address of the target PM H/W */
+   uint16_t  targetIpv4Port;       /* IPv4 port of the target PM H/W */
+   uint32_t  targetChannelId;      /* channel of the target PM H/W */
+   uint32_t  pmlaChannelTimeout;   /* PMLA channel timeout - used with reads */
+   bool      option8572rev1_0Flag; /* Special compiler option set flag */
+} _pmcd_app_params_t;
+
+/* This type defines a name structure as used by the PMCD functions.
+ * The maximum length of a name is PM_NAME_MAX_LENGTH characters
+ * including the terminating NULL character. */
+typedef char  _pmcd_name_t[PM_NAME_MAX_LENGTH];
+
+/* This type defines the pmcd expression record. */
+typedef struct {
+   dll_node_t  dll_node;
+   char        name_s[_PMCD_NAME_STRING_MAX_SIZE];
+   char        exp_s[_PMCD_EXP_STRING_MAX_SIZE];
+   char        options_s[_PMCD_EXP_OPTIONS_STRING_MAX_SIZE];
+   uint32_t    pmcdIndex;
+   uint32_t    llIndex;
+   uint8_t     set;
+   uint16_t    subset;
+} _pmcd_exp_record_t;
+
+
+/* This type defines the pmcd rule record. */
+typedef struct {
+   char          name_s[_PMCD_NAME_STRING_MAX_SIZE];
+   uint32_t      reactionNum;
+   _pmcd_name_t *reactionNames_p;
+   uint32_t      pmcdIndex;
+   uint32_t      llIndex;
+} _pmcd_rule_record_t;
+
+
+/* This type contains data associated with a PM database. */
+typedef struct {
+  unsigned int           llDbHandle;
+  handle_t               pmlaForPmllHandle;
+  handle_t               pmlaForPmcdHandle;
+  handle_t               expDbHandle;
+  handle_t               ruleDbHandle;
+  pmp_statistics_attr_t  snapshot;
+  bool                   option8572rev1_0;
+  dll_list_t             set[_PMCD_NUM_SETS];
+} _pmcd_db_t;
+
+
+#endif /* PMCD_H_INCLUDE */
-- 
1.6.0

