From acbba696f2824b719a473a1a0a4278ef307c11c8 Mon Sep 17 00:00:00 2001
From: Paul Barrette <paul.barrette@freescale.com>
Date: Wed, 14 Oct 2009 17:07:19 -0400
Subject: [PATCH 1/1] Updated to remove all ifdef _KERNEL_ defines.

This file is a shared resource between kernel and userspace.
Changes checked in on behalf of Jeffrey Ladouceur.

Signed-off-by: Paul Barrette <paul.barrette@freescale.com>
---
 include/fsl_pme.h |  384 +----------------------------------------------------
 1 files changed, 2 insertions(+), 382 deletions(-)

diff --git a/include/fsl_pme.h b/include/fsl_pme.h
index d3ae22e..7c0737b 100644
--- a/include/fsl_pme.h
+++ b/include/fsl_pme.h
@@ -83,6 +83,7 @@ enum pme_status {
 /* pme_fd_res_flags() returns these flags */
 #define PME_STATUS_UNRELIABLE	0x80
 #define PME_STATUS_TRUNCATED	0x10
+#define PME_STATUS_MASK		0x90
 
 /**************/
 /* USER SPACE */
@@ -235,386 +236,5 @@ struct pme_db_sre_reset {
 	__u16 rule_reset_interval;
 	__u8 rule_reset_priority;
 };
-
-/****************/
-/* KERNEL SPACE */
-/****************/
-
-#ifdef __KERNEL__
-
-#include <linux/fsl_qman.h>
-#include <linux/fsl_bman.h>
-
-/* "struct pme_hw_flow" represents a flow-context resource for h/w, whereas
- * "struct pme_flow" (below) is the s/w type used to provide (and receive)
- * parameters to(/from) the h/w resource. */
-struct pme_hw_flow;
-
-/* "struct pme_hw_residue" represents a residue resource for h/w. */
-struct pme_hw_residue;
-
-/* This is the pme_flow structure type, used for querying or updating a PME flow
- * context */
-struct pme_flow {
-	u8 sos:1;
-	u8 __reserved1:1;
-	u8 srvm:2;
-	u8 esee:1;
-	u8 __reserved2:3;
-	u8 ren:1;
-	u8 rlen:7;
-	/* Sequence Number (48-bit) */
-	u16 seqnum_hi;
-	u32 seqnum_lo;
-	u32 __reserved3;
-	u32 sessionid:27;
-	u32 __reserved4:5;
-	u16 __reserved5;
-	/* Residue pointer (48-bit), ignored if ren==0 */
-	u16 rptr_hi;
-	u32 rptr_lo;
-	u16 clim;
-	u16 mlim;
-	u32 __reserved6;
-} __packed;
-
-/* pme_ctx_update(), pme_fd_cmd_fcw() and pme_scan_params::flags use these; */
-#define PME_CMD_FCW_RES	0x80	/* "Residue": ren, rlen, rptr */
-#define PME_CMD_FCW_SEQ	0x40	/* "Sequence": sos, sequnum */
-#define PME_CMD_FCW_SRE	0x20	/* "Stateful Rule": srvm, esee, sessionid */
-#define PME_CMD_FCW_DXE	0x10	/* "Data Examination": clim, mlim */
-#define PME_CMD_FCW_ALL 0xf0
-
-/* pme_ctx_scan() and pme_fd_cmd_scan() use these; */
-#define PME_CMD_SCAN_SRVM(n) ((n) << 3) /* n in [0..3] */
-#define PME_CMD_SCAN_FLUSH 0x04
-#define PME_CMD_SCAN_SR    0x02 /* aka "Start of Flow or Reset */
-#define PME_CMD_SCAN_E     0x01 /* aka "End of Flow */
-
-/***********************/
-/* low-level functions */
-/***********************/
-
-/* (De)Allocate PME hardware resources */
-struct pme_hw_residue *pme_hw_residue_new(void);
-void pme_hw_residue_free(struct pme_hw_residue *);
-struct pme_hw_flow *pme_hw_flow_new(void);
-void pme_hw_flow_free(struct pme_hw_flow *);
-
-/* Software 'flow' structures also have alignment requirements, so use these to
- * allocate them. */
-struct pme_flow *pme_sw_flow_new(void);
-void pme_sw_flow_free(struct pme_flow *);
-
-/* Fill in an "Initialise FQ" management command for a PME input FQ. NB, the
- * caller is responsible for setting the following fields, they will not be set
- * by the API;
- *   - initfq->fqid, the frame queue to be initialised
- *   - initfq->count, should most likely be zero. A count of 0 initialises 1 FQ,
- *   			a count of 1 initialises 2 FQs, etc/
- * The 'qos' parameter indicates which workqueue in the PME channel the
- * FQ should schedule to for regular scanning (0..7). If 'flow' is non-NULL the
- * FQ is configured for Flow Mode, otherwise it is configured for Direct Action
- * Mode. 'bpid' is the buffer pool ID to use when Bman-based output is
- * produced, and 'rfqid' is the frame queue ID to enqueue output frames to.
- * Following this api, when calling qm_mc_commit(), use QM_MCC_VERB_INITFQ_SCHED
- * for regular PMEscanning or QM_MCC_VERB_INITFQ_PARK for exclusive PME
- * processing (usually PMTCC).*/
-void pme_initfq(struct qm_mcc_initfq *initfq, struct pme_hw_flow *flow, u8 qos,
-		u8 rbpid, u32 rfqid);
-
-/* Given a dequeued frame from PME, return status/flags */
-static inline enum pme_status pme_fd_res_status(const struct qm_fd *fd)
-{
-	return (enum pme_status)(fd->status >> 24);
-}
-static inline u8 pme_fd_res_flags(const struct qm_fd *fd)
-{
-	return (fd->status >> 16) & 0xff;
-}
-
-/* Fill in a frame descriptor for a NOP command. */
-void pme_fd_cmd_nop(struct qm_fd *fd);
-
-/* Fill in a frame descriptor for a Flow Context Write command. NB, the caller
- * is responsible for setting all the relevant fields in 'flow', only the
- * following fields are set by the API;
- *   - flow->rptr_hi
- *   - flow->rptr_lo
- * The fields in 'flow' are divided into 4 groups, 'flags' indicates which of
- * them should be written to the h/w flow context using PME_CMD_FCW_*** defines.
- * 'residue' should be non-NULL iff flow->ren is non-zero and PME_CMD_FCW_RES is
- * set. */
-void pme_fd_cmd_fcw(struct qm_fd *fd, u8 flags, struct pme_flow *flow,
-		struct pme_hw_residue *residue);
-
-/* Fill in a frame descriptor for a Flow Context Read command. */
-void pme_fd_cmd_fcr(struct qm_fd *fd, struct pme_flow *flow);
-
-/* Modify a frame descriptor for a PMTCC command (only modifies 'cmd' field) */
-void pme_fd_cmd_pmtcc(struct qm_fd *fd);
-
-/* Modify a frame descriptor for a Scan command (only modifies 'cmd' field).
- * 'flags' are chosen from PME_CMD_SCAN_*** symbols. NB, the use of the
- * intermediary representation (and PME_SCAN_ARGS) improves performance - ie.
- * if the scan params are essentially constant, this compacts them for storage
- * into the same format used in the interface to h/w. So it reduces parameter
- * passing, stack-use, and encoding time. */
-#define PME_SCAN_ARGS(flags, set, subset) \
-({ \
-	u8 __flags461 = (flags); \
-	u8 __set461 = (set); \
-	u16 __subset461 = (subset); \
-	u32 __res461 = ((u32)__flags461 << 24) | \
-			((u32)__set461 << 16) | \
-			(u32)__subset461; \
-	__res461; \
-})
-void pme_fd_cmd_scan(struct qm_fd *fd, u32 args);
-
-/* convert pointer to physical address for use by PME */
-dma_addr_t pme_map(void *ptr);
-int pme_map_error(dma_addr_t dma_addr);
-
-/************************/
-/* high-level functions */
-/************************/
-
-struct pme_ctx;
-
-/* Calls to pme_ctx_scan() and pme_ctx_pmtcc() provide these, and they are
- * provided back in the completion callback. You can embed this within a larger
- * structure in order to maintain per-command data of your own. The fields are
- * owned by the driver until the callback is invoked, so for example do not link
- * this token into a list while the command is in-flight! */
-struct pme_ctx_token {
-	u32 blob[4];
-	struct list_head node;
-};
-
-/* Scan results invoke a user-provided callback of this type */
-typedef void (*pme_scan_cb)(struct pme_ctx *, const struct qm_fd *,
-				struct pme_ctx_token *);
-
-/* PME "association" - ie. connects two frame-queues, with or without a PME flow
- * (if not, direct action mode), and manages mux/demux of scans and flow-context
- * updates. To allow state used by your callback to be stashed, as well as
- * optimising the PME driver and the Qman driver beneath it, embed this
- * structure as the first field in your own context structure. */
-struct pme_ctx {
-	struct qman_fq fq;
-	/* IMPORTANT: Set (only) these prior to calling pme_ctx_init(); */
-	pme_scan_cb cb;
-	struct bman_pool *pool;
-	/* These fields should not be manipulated directly. Also the structure
-	 * may change and/or grow, so avoid making any alignment or size
-	 * assumptions. */
-	atomic_t refs;
-	volatile u32 flags;
-	spinlock_t lock;
-	wait_queue_head_t queue;
-	struct list_head tokens;
-	u32 seq_num;
-	/* TODO: the following "slow-path" values should be bundled into a
-	 * secondary structure so that sizeof(struct pme_ctx) is minimised (for
-	 * stashing of caller-side fast-path state). */
-	u32 uid;
-	struct qman_fq *fqin;
-	struct pme_hw_flow *hw_flow;
-	struct pme_hw_residue *hw_residue;
-	struct qm_fqd_stashing stashing;
-	struct qm_fd update_fd;
-};
-
-/* Flags for pme_ctx_init() */
-#define PME_CTX_FLAG_LOCKED      0x00000001 /* use QMAN_FQ_FLAG_LOCKED */
-#define PME_CTX_FLAG_EXCLUSIVE   0x00000002 /* unscheduled, exclusive mode */
-#define PME_CTX_FLAG_PMTCC       0x00000004 /* PMTCC rather than scanning */
-#define PME_CTX_FLAG_DIRECT      0x00000008 /* Direct Action mode (not Flow) */
-#define PME_CTX_FLAG_NO_ORP      0x00000010 /* Using this flags implies there
-					     * is no risk of enqueue misordering
-					     */
-#define PME_CTX_FLAG_LOCAL       0x00000020 /* Ignore dest, use cpu portal */
-
-/* Flags for operations */
-#define PME_CTX_OP_WAIT          QMAN_ENQUEUE_FLAG_WAIT
-#define PME_CTX_OP_WAIT_INT      QMAN_ENQUEUE_FLAG_WAIT_INT
-#define PME_CTX_OP_RESETRESLEN   0x00000001 /* no en/disable, just set len */
-/* note that pme_ctx_update() uses PME_CMD_FCW flags, they mustn't conflict */
-/* also, we match QMAN_ENQUEUE values to optimise fast-path operations (which
- * don't wait, and shouldn't incur conditional PME->QMAN flag conversions). */
-
-/**
- * pme_ctx_init - Initialise a PME context
- * @ctx: the context structure to initialise
- * @flags: bit-mask of PME_CTX_FLAG_*** options
- * @bpid: buffer pool ID used for any Bman-generated output
- * @qosin: workqueue priority on the PME channel (0-7)
- * @qosout: workqueue priority on the result channel (0-7)
- * @dest: channel to receive results from PME
- * @stashing: desired dequeue stashing behaviour
- *
- * This creates and initialises a PME context, composed of two FQs, an optional
- * flow-context, and scheduling parameters for the datapath. The ctx->cb and
- * ctx->pool fields must have been initialised prior to calling this api. The
- * initialised context is left 'disabled', meaning that the FQ towards PME is
- * Parked and no operations are possible. If PME_CTX_INIT_EXCLUSIVE is specified
- * in @flags, then the input FQ is not scheduled, otherwise enabling the context
- * will schedule the FQ to PME. Exclusive access is only available if the driver
- * is built with control functionality and if the operating system has access to
- * PME's CCSR map. @qosin applies if EXCLUSIVE is not set, and indicates which
- * of the PME's 8 prioritised workqueues the FQ should schedule to. @dest
- * indicates the channel that should receive results from PME, unless
- * PME_CTX_FLAG_LOCAL is set in which case this parameter is ignored and the
- * dedicated portal channel for the current cpu will be used instead. @qosout
- * indicates which of the 8 prioritised workqueus the FQ should schedule to on
- * the s/w portal. @stashing configures whether FQ context, frame data, and/or
- * frame annotation should be stashed into cpu cache when dequeuing output, and
- * if so, how many cachelines.  For the FQ context part, set the number of
- * cachelines to cover; 1. sizeof(struct qman_fq_base), to accelerate only Qman
- * driver processing, 2. sizeof(struct pme_ctx), to accelerate Qman and PME
- * driver processing, or 3. sizeof(<user-struct>), where <user-struct> is the
- * caller's structure of which the pme_ctx is the first member - this will allow
- * callbacks to operate on state which has a high probability of already being
- * in-cache.
- * Returns 0 on success.
- */
-int pme_ctx_init(struct pme_ctx *ctx, u32 flags, u32 bpid, u8 qosin,
-			u8 qosout, enum qm_channel dest,
-			const struct qm_fqd_stashing *stashing);
-
-/* Cleanup allocated resources */
-void pme_ctx_finish(struct pme_ctx *ctx);
-
-/* disable a context, on return the ctx is fully disabled (quiesced) and returns
- * zero, or it returns an error and remains enabled. flags can be:
- * PME_CTX_OP_WAIT and/or PME_CTX_OP_WAIT_INT */
-int pme_ctx_disable(struct pme_ctx *ctx, u32 flags);
-
-/* enable a context */
-int pme_ctx_enable(struct pme_ctx *ctx);
-
-/* query whether a context is disabled. Returns > 0 if the ctx is disabled. */
-int pme_ctx_is_disabled(struct pme_ctx *ctx);
-
-/* A pre-condition for the following APIs is the ctx must be disabled
- * dest maybe ignored if the flags parameter indicated LOCAL during the
- * corresponding pme_ctx_init.
- */
-int pme_ctx_reconfigure_tx(struct pme_ctx *ctx, u32 bpid, u8 qosin);
-int pme_ctx_reconfigure_rx(struct pme_ctx *ctx, u8 qosout,
-		enum qm_channel dest, const struct qm_fqd_stashing *stashing);
-
-/* Precondition: pme_ctx must be enabled */
-/* NB: _update() and _nop() only return failure if their PME commands weren't
- * sent. If PME_CTX_OP_WAIT_INT was specified and a signal was received while
- * waiting for the response, it may return prematurely with success. The caller
- * can use signal_pending() to deal with any corresponding issues, if required.
- * Also 'params' may be modified by this call. For instance if
- * PME_CTX_OP_RESETRESLEN was specified and residue is enabled, then the
- * params->ren will be set to 1 (in order not to disabled residue).
- * NB: _read_flow() is a blocking/sleeping and uninterruptible API, so it must
- * not be called in atomic context and will not break due to signals.
- * PME_CTX_OP_WAIT flag will be assumed set and PME_CTX_OP_WAIT_INT will be
- * assumed cleared, irrespective of what is specified in 'flags'.
- */
-int pme_ctx_ctrl_update_flow(struct pme_ctx *ctx, u32 flags,
-			struct pme_flow *params);
-int pme_ctx_ctrl_read_flow(struct pme_ctx *ctx, u32 flags,
-			struct pme_flow *params);
-int pme_ctx_ctrl_nop(struct pme_ctx *ctx, u32 flags);
-
-/* if PME_CTX_OP_WAIT is specified, it'll wait (if it has to) to start the scan
- * but never waits for it to complete. The scan callback serves that purpose.
- * 'fd' is modified by both these calls, but only the 'cmd' field. The 'args'
- * parameters is produced by the PME_SCAN_ARGS() inline function. */
-int pme_ctx_scan(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd, u32 args,
-		struct pme_ctx_token *token);
-int pme_ctx_pmtcc(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
-		struct pme_ctx_token *token);
-
-/* Precondition: must be PME_CTX_FLAG_EXCLUSIVE */
-int pme_ctx_exclusive_inc(struct pme_ctx *ctx, u32 flags);
-void pme_ctx_exclusive_dec(struct pme_ctx *ctx);
-
-/**************************/
-/* control-plane only API */
-/**************************/
-#ifdef CONFIG_FSL_PME2_CTRL
-
-/* Attributes for pme_reg_[set|get]() */
-enum pme_attr {
-	pme_attr_efqc_int,
-	pme_attr_sw_db,
-	pme_attr_kvlts,
-	pme_attr_max_chain_length,
-	pme_attr_pattern_range_counter_idx,
-	pme_attr_pattern_range_counter_mask,
-	pme_attr_max_allowed_test_line_per_pattern,
-	pme_attr_max_pdsr_index,
-	pme_attr_max_pattern_matches_per_sui,
-	pme_attr_max_pattern_evaluations_per_sui,
-	pme_attr_report_length_limit,
-	pme_attr_end_of_simple_sui_report,
-	pme_attr_aim,
-	pme_attr_sre_context_size,
-	pme_attr_sre_rule_num,
-	pme_attr_sre_session_ctx_num,
-	pme_attr_end_of_sui_reaction_ptr,
-	pme_attr_sre_pscl,
-	pme_attr_sre_max_block_num,
-	pme_attr_sre_max_instruction_limit,
-	pme_attr_sre_max_index_size,
-	pme_attr_sre_max_offset_ctrl,
-	pme_attr_src_id,
-	pme_attr_liodnr,
-	pme_attr_rev1,
-	pme_attr_rev2,
-	pme_attr_srrv0,
-	pme_attr_srrv1,
-	pme_attr_srrv2,
-	pme_attr_srrv3,
-	pme_attr_srrv4,
-	pme_attr_srrv5,
-	pme_attr_srrv6,
-	pme_attr_srrv7,
-	pme_attr_srrfi,
-	pme_attr_srri,
-	pme_attr_srrwc,
-	pme_attr_srrr,
-	pme_attr_trunci,
-	pme_attr_rbc,
-	pme_attr_tbt0ecc1ec,
-	pme_attr_tbt1ecc1ec,
-	pme_attr_vlt0ecc1ec,
-	pme_attr_vlt1ecc1ec,
-	pme_attr_cmecc1ec,
-	pme_attr_dxcmecc1ec,
-	pme_attr_dxemecc1ec,
-	pme_attr_stnib,
-	pme_attr_stnis,
-	pme_attr_stnth1,
-	pme_attr_stnth2,
-	pme_attr_stnthv,
-	pme_attr_stnths,
-	pme_attr_stnch,
-	pme_attr_stnpm,
-	pme_attr_stns1m,
-	pme_attr_stnpmr,
-	pme_attr_stndsr,
-	pme_attr_stnesr,
-	pme_attr_stns1r,
-	pme_attr_stnob,
-	pme_attr_mia_byc,
-	pme_attr_mia_blc,
-	pme_attr_isr
-};
-
-/* Get/set driver attributes */
-int pme_attr_set(enum pme_attr attr, u32 val);
-u32 pme_attr_get(enum pme_attr attr);
-#endif /* defined(CONFIG_FSL_PME2_CTRL) */
-
-#endif /* __KERNEL__ */
-
 #endif /* FSL_PME_H */
+
-- 
1.6.0

